<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Refuel Assist v7.3.46 - Hesaplama</title>
    <meta name="theme-color" content="#0f172a">
    <link rel="manifest" href="manifest.json">
    <script src="assets/tailCapacityLoader.js"></script>
    <link rel="icon" type="image/png" href="assets/logo-192.png">
    <link rel="apple-touch-icon" href="assets/logo-192.png">
    <style>
        :root { --primary: #38bdf8; --success: #22c55e; --warning: #fbbf24; --error: #ef4444; --bg: #0f172a; --card-bg: #1e293b; --density-clr: #a855f7; --temp-clr: #10b981; --amber: #f59e0b; --header-h: 58px; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: var(--bg); color: white; margin: 0; display: flex; justify-content: center; overflow-x: hidden; }
        .page { width: 100%; max-width: 420px; padding: 12px; box-sizing: border-box; }
        .card { background: var(--card-bg); padding: 12px; border-radius: 26px; border: 1px solid #334155; }
        .input-group { background: #111827; padding: 12px; border-radius: 22px; border: 1.5px solid var(--amber); margin-bottom: 10px; transition: border-color 0.3s, box-shadow 0.3s; box-shadow: 0 0 0 1px rgba(100,116,139,0.08); }
        .input-group.state-empty { border-color: var(--amber); }
        .input-group.state-empty { box-shadow: 0 0 12px rgba(245,158,11,0.10); }
        .input-group.state-empty .group-label { color: var(--amber) !important; }
        .input-group.state-empty .btn-step { background: rgba(245,158,11,0.15); border-color: rgba(245,158,11,0.35); color: var(--amber); }
        .input-group.state-empty .main-input { color: white; }
        .input-group.state-error { border-color: var(--error); box-shadow: 0 0 12px rgba(239,68,68,0.18); }
        .input-group.state-error .group-label { color: var(--error) !important; }
        .input-group.state-error .btn-step { background: rgba(239,68,68,0.15); border-color: rgba(239,68,68,0.35); color: var(--error); }
        .input-group.state-error .main-input { color: white; }
        .input-group.state-valid { border-color: #64748b; box-shadow: 0 0 12px rgba(148,163,184,0.08); }
        .input-group.state-valid .group-label { color: #64748b !important; }
        .input-group.state-valid .btn-step { background: rgba(100,116,139,0.18); border-color: rgba(100,116,139,0.35); color: #94a3b8; }
        .input-group.state-valid .main-input { color: white; }

        .group-label { font-size: 10px; font-weight: 800; color: var(--amber); text-transform: uppercase; margin-bottom: 6px; display: block; text-align: center; transition: color 0.3s; }
            .main-input { background: #0f172a; border: 1px solid #334155; color: white; text-align: center; border-radius: 14px; font-size: 22px; width: 100%; height: 46px; font-weight: 700; outline: none; -webkit-appearance: none; -moz-appearance: textfield; box-sizing: border-box; transition: border-color 0.25s, box-shadow 0.25s; }
            /* Input'un kendi çerçevesi focus vurgusu */
            .main-input:focus { border-color: #94a3b8; box-shadow: 0 0 0 3px rgba(148,163,184,0.16); }
            .input-group.state-empty .main-input:focus { border-color: var(--amber); box-shadow: 0 0 0 3px rgba(245,158,11,0.18), 0 0 10px rgba(245,158,11,0.08); }
            .input-group.state-error .main-input:focus { border-color: var(--error); box-shadow: 0 0 0 3px rgba(239,68,68,0.18), 0 0 10px rgba(239,68,68,0.08); }
            .input-group.state-valid .main-input:focus { border-color: #94a3b8; box-shadow: 0 0 0 3px rgba(148,163,184,0.16); }
            /* Odaklanan input grubunu vurgula: sadece hafif gölge uygulansın, state renklerini bozmayalım */
            .input-group.focused { box-shadow: 0 8px 26px rgba(148,163,184,0.08); }
            /* Label rengini state-* sınıfları belirlesin; burada override yapmıyoruz */
        .main-input::-webkit-outer-spin-button,
        .main-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .input-with-unit { position: relative; flex: 1; min-width: 0; }
        .input-with-unit .main-input { padding-left: 18px; padding-right: 18px; }
        .input-with-unit .unit-suffix { display: none; }
        .input-with-unit .unit-corner {
            position: absolute;
            right: 10px;
            bottom: 8px;
            font-size: 9px;
            font-weight: 800;
            letter-spacing: 0.4px;
            color: #64748b;
            pointer-events: none;
            text-transform: uppercase;
            line-height: 1;
            opacity: 0.55;
            transition: color 0.2s, transform 0.18s;
            transform: translateY(2px);
        }
        /* Make temp inputs fit up to 3 digits comfortably */
        #box_temp .input-with-unit .main-input {
            font-size: clamp(14px, 2.2vw, 18px) !important;
            padding-left: 6px !important;
            padding-right: 6px !important;
            height: 48px !important;
        }
        .input-group.state-empty .unit-corner { color: var(--amber); }
        .input-group.state-error .unit-corner { color: var(--error); }
        .input-group.state-valid .unit-corner { color: #64748b; }
        .btn-step { background: rgba(245,158,11,0.15); border: 1.5px solid rgba(245,158,11,0.35); color: var(--amber); width: 46px; height: 46px; border-radius: 14px; font-size: 22px; flex-shrink: 0; transition: background 0.3s, border-color 0.3s, color 0.3s; }
        .btn-step:active { opacity: 0.7; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-4px); } 40%, 80% { transform: translateX(4px); } }
        .shake { animation: shake 0.3s ease-in-out; }
        .btn-step-warning { background: rgba(251,191,36,0.15); border: 1.5px solid rgba(251,191,36,0.35); color: #fbbf24; }
        .btn-step-warning:active { opacity: 0.7; }
        /* Tank group: rely on parent .input-group border, keep internal separators */
        .tank-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 0;
            margin-top: 10px;
            background: transparent;
        }
        .tank-box {
            background: transparent;
            padding: 6px 6px; /* reduced horizontal padding to maximize input width */
            border-radius: 0;
            border: none;
            text-align: center;
            transition: none;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: flex-start;
            min-height: 94px;
        }
        /* vertical separator between boxes */
        .tank-box + .tank-box { border-left: 1px solid rgba(255,255,255,0.06); }
        /* restore rounded corners on the outer boxes */
        .tank-box:first-child { border-top-left-radius: 20px; border-bottom-left-radius: 20px; }
        .tank-box:last-child { border-top-right-radius: 20px; border-bottom-right-radius: 20px; }

        /* Modal içi kaydırma çubuğu: çerçevesiz, ince ve kibar */
        .warning-scroll { scrollbar-width: thin; scrollbar-color: rgba(148,163,184,0.45) transparent; }
        .warning-scroll::-webkit-scrollbar { width: 8px; }
        .warning-scroll::-webkit-scrollbar-track { background: transparent; }
        .warning-scroll::-webkit-scrollbar-thumb {
            background-color: rgba(148,163,184,0.35);
            border-radius: 999px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        .warning-scroll::-webkit-scrollbar-thumb:hover { background-color: rgba(148,163,184,0.50); }
        .tank-box span { font-size: 11px; font-weight: 900; color: #64748b; text-transform: uppercase; letter-spacing: 0.8px; transition: color 0.3s; display:block; margin-top: 0; margin-bottom: 4px; }

        .tank-mid { flex: 1; display:flex; align-items:center; justify-content:center; padding: 0; }

        /* Tank input alanının kendi çerçevesi focus vurgusu */
            .tank-input-wrap {
                position: relative;
                width: 100%;
                align-self: stretch;
                border-radius: 12px;
                background: rgba(15,23,42,0.95);
                border: 1px solid #334155;
                box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
                transition: box-shadow 0.25s, border-color 0.25s;
                padding: 0 4px; /* tighten inner gutter */
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                max-width: 100%;
                overflow: visible;
                min-width: 0;
                margin: 0;
                box-sizing: border-box;
            }
            .tank-input-wrap:focus-within { box-shadow: inset 0 0 0 2px rgba(148,163,184,0.35), 0 0 10px rgba(148,163,184,0.08); }
            .input-group.state-empty .tank-input-wrap:focus-within { box-shadow: inset 0 0 0 2px rgba(245,158,11,0.45), 0 0 10px rgba(245,158,11,0.08); }
        .cat-info-btn{flex:0 0 34px;width:34px;height:34px;border-radius:10px;background:rgba(245,158,11,0.10);border:1px solid rgba(245,158,11,0.18);color:var(--amber);font-weight:900;cursor:pointer}
            .input-group.state-error .tank-input-wrap:focus-within { box-shadow: inset 0 0 0 2px rgba(239,68,68,0.45), 0 0 10px rgba(239,68,68,0.08); }
            .input-group.state-valid .tank-input-wrap:focus-within { box-shadow: inset 0 0 0 2px rgba(148,163,184,0.35), 0 0 10px rgba(148,163,184,0.08); }
        /* Input group içindeki ACT tank kutuları */
        .input-group.state-empty .tank-box { border-color: rgba(245,158,11,0.4); }
        .input-group.state-empty .tank-box span { color: var(--amber); }
        .input-group.state-error .tank-box { border-color: rgba(239,68,68,0.4); }
        .input-group.state-error .tank-box span { color: var(--error); }
        .input-group.state-valid .tank-box { border-color: #475569; }
        .input-group.state-valid .tank-box span { color: #64748b; }
        /* Dashboard içindeki TGT tank kutuları */
        .dashboard.result-disabled .tank-box { border-color: #475569; }
        .dashboard.result-disabled .tank-box span { color: #64748b; }
        .dashboard.result-ready .tank-box { border-color: var(--success); box-shadow: 0 0 8px rgba(34,197,94,0.15); }
        .dashboard.result-ready .tank-box span { color: white; }
        .tank-input { width: 100%; background: transparent; border: none; color: white; text-align: center; font-size: clamp(14px, 2.8vw, 18px); font-weight: 700; outline: none; appearance: none; -webkit-appearance: none; -moz-appearance: textfield; transition: color 0.3s; padding-left: 6px; padding-right: 6px; box-sizing: border-box; }
        .tank-input::-webkit-outer-spin-button,
        .tank-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .tank-input::placeholder { color: #64748b; }
        .tank-input-wrap .tank-unit { display: none; }
        .tank-unit-corner {
            position: absolute;
            right: 8px;
            bottom: 6px;
            font-size: 9px;
            font-weight: 800;
            letter-spacing: 0.3px;
            color: #64748b;
            text-transform: uppercase;
            pointer-events: none;
            transition: color 0.2s, transform 0.18s;
            opacity: 0.5;
            line-height: 1;
            transform: translateY(2px);
        }
        .tank-unit-corner.tank-unit-tgt {
            font-size: 9px;
            bottom: 6px;
        }
        /* Hide KG labels for tank inputs/targets as requested */
        .tank-input-wrap .tank-unit-corner,
        .tank-unit-corner.tank-unit-tgt { display: none !important; }
        .input-group.state-empty .tank-input { color: var(--amber); }
        .input-group.state-empty .tank-unit-corner { color: var(--amber); }
        .input-group.state-error .tank-input { color: var(--error); }
        .input-group.state-error .tank-unit-corner { color: var(--error); }
        .input-group.state-valid .tank-input { color: white; }
        .input-group.state-valid .tank-unit-corner { color: #64748b; }
        .btn-mini { background: rgba(100,116,139,0.18); border: 1px solid rgba(100,116,139,0.30); color: #94a3b8; width: 28px; height: 28px; border-radius: 14px; font-size: 17px; cursor: pointer; transition: background 0.3s, border-color 0.3s, color 0.3s; }
        .btn-mini:active { opacity: 0.7; }
        .btn-mini:disabled { opacity: 0.15; cursor: not-allowed; }

        .tank-step-row { display:flex; justify-content:center; gap:14px; padding-top: 6px; }

        /* Allow action row buttons to wrap on narrow screens */
        .action-row > div { display: flex; gap: 14px; width: 100%; flex-wrap: wrap; }

        /* Ensure tank boxes can shrink below content width when needed */
        .tank-box { min-width: 0; }

        /* Responsive tweaks for small screens */
        @media (max-width: 420px) {
            .tank-input-wrap { max-width: 100%; }
            .btn-step { width: 40px; height: 40px; font-size: 18px; }
            .btn-mini { width: 32px; height: 32px; font-size: 15px; }
            .input-with-unit .main-input { font-size: 20px; }
            .tank-input { font-size: 16px; }
            .tgt-val { font-size: 16px; }
            .save-btn { padding: 12px; font-size: 14px; }
            .input-capsule { padding-left: 10px; padding-right: 10px; }
        }
        /* Input group içindeki ACT butonları */
        .input-group.state-empty .btn-mini { background: rgba(245,158,11,0.12); border-color: rgba(245,158,11,0.3); color: var(--amber); }
        .input-group.state-error .btn-mini { background: rgba(239,68,68,0.12); border-color: rgba(239,68,68,0.3); color: var(--error); }
        .input-group.state-valid .btn-mini { background: rgba(100,116,139,0.18); border-color: rgba(100,116,139,0.3); color: #94a3b8; }
        /* Dashboard içindeki TGT butonları */
        .dashboard.result-ready .btn-mini { background: rgba(34,197,94,0.15); border-color: rgba(34,197,94,0.35); color: var(--success); }
        .dashboard.result-ready .btn-mini:disabled { opacity: 0.25; }
        .dashboard { background: #0f172a; border-radius: 24px; border: 2px solid #64748b; padding: 12px; margin-top: 10px; transition: border-color 0.3s, box-shadow 0.3s, opacity 0.3s; box-shadow: 0 0 12px rgba(148,163,184,0.06); }
        .dashboard.result-disabled { opacity: 0.4; filter: grayscale(0.8); border-color: #475569; }
        .dashboard.result-ready { border-color: var(--success); box-shadow: 0 0 18px rgba(34,197,94,0.18); }
        .tgt-val { display: inline-flex; align-items: center; justify-content: center; width: 100%; font-size: clamp(12px, 3.6vw, 20px); font-weight: 800; color: #64748b; margin: 0; transition: color 0.3s; text-align: center; padding: 0 8px; box-sizing: border-box; white-space: nowrap; overflow: visible; position: relative; z-index: 3; }
        .dashboard.result-disabled .tgt-val { color: #64748b; }
        .dashboard.result-disabled .tank-unit-corner { color: #475569; }
        .dashboard.result-ready .tgt-val { color: white; }
        .dashboard.result-ready .tank-unit-corner { color: var(--success); }
        .uplift-container { background: #181e29; border-radius: 20px; border-top: 2px solid #475569; margin-top: 10px; padding: 15px 0; text-align: center; transition: border-color 0.3s; }
        .dashboard.result-disabled .uplift-container { border-top-color: #475569; }
        .dashboard.result-ready .uplift-container { border-top-color: var(--success); }
        .uplift-title { font-size:10px; color:#64748b; font-weight:900; letter-spacing:0.12em; margin-bottom:8px; }
        .uplift-split { display:grid; grid-template-columns: 1fr 1fr; }
        .uplift-unit { font-size:10px; color:#64748b; font-weight:800; }
        .uplift-cell-right { border-left: 1px solid rgba(255,255,255,0.1); }
        .val-num { font-size: 28px; font-weight: 900; color: #64748b; }
        .save-btn { width: 100%; background: var(--success); border: none; color: white; padding: 20px; border-radius: 22px; font-weight: 800; margin: 15px 0; font-size: 16px; transition: opacity 0.3s, box-shadow 0.3s, transform 0.2s; }
        .save-btn:disabled { opacity: 0.3; cursor: not-allowed; filter: grayscale(1); box-shadow: none; }
        .save-btn:not(:disabled) { box-shadow: 0 0 18px rgba(34,197,94,0.4); }
        .save-btn:not(:disabled):active { transform: scale(0.98); }
        .field-error { display: none; }

        .notice-area {
            position: relative;
            margin: 0 -12px 12px -12px;
        }
        .notice {
            --notice-accent: var(--error);
            background: rgba(15,23,42,0.92);
            border: none;
            border-radius: 14px;
            padding: 10px 14px;
            display: flex;
            justify-content: center;
            text-align: center;
            position: fixed; /* always fixed overlay */
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 24px);
            max-width: 420px;
            overflow: hidden;
            font-size: 11px;
            font-weight: 800;
            letter-spacing: 0.15px;
            text-transform: none;
            line-height: 1.35;
            color: white;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 6px 24px rgba(0,0,0,0.45), 0 0 12px rgba(239,68,68,0.10);
            z-index: 9999;
            box-sizing: border-box;
        }
        .notice-text { position: relative; display: inline-block; max-width: 100%; }
        .notice-text::after {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            bottom: -8px;
            height: 3px;
            border-radius: 9999px;
            background: linear-gradient(90deg, transparent 0%, var(--notice-accent) 50%, transparent 100%);
            opacity: 0.35;
            pointer-events: none;
            box-shadow: 0 0 14px var(--notice-accent);
            filter: drop-shadow(0 0 10px var(--notice-accent));
        }
        .notice:not(.hidden) .notice-text::after { animation: notice-bar-loop 1600ms ease-in-out infinite; }
        @keyframes notice-bar-loop {
            0%, 100% { opacity: 0.30; }
            50% { opacity: 0.85; }
        }
        @media (prefers-reduced-motion: reduce) {
            .notice:not(.hidden) .notice-text::after { animation: none; }
        }
        .notice.hidden { display: none; }
        #log-list { margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; }
        .log-item { background: rgba(255,255,255,0.05); padding: 14px; border-radius: 18px; margin-bottom: 8px; border-left: 5px solid var(--primary); cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .del-log { color: var(--error); background: rgba(239, 68, 68, 0.1); border: none; width: 26px; height: 26px; border-radius: 8px; font-weight: 900; }

        .lang-toggle-inline button.active {
            color: #ffffff !important;
            background: rgba(56,189,248,0.18) !important;
        }
    </style>
</head>
<body>
    <div id="logs-page" class="page" style="display:none; padding-top: 24px; padding-bottom: 24px;">
        <div class="card" style="margin-bottom: 24px;">
            <div style="display:flex; align-items:center; gap:10px; margin-bottom: 10px;">
                <button onclick="setView('')" aria-label="Back" style="width:44px; height:44px; padding:0; border-radius:14px; background: rgba(56,189,248,0.12); border: 1.5px solid rgba(56,189,248,0.22); cursor:pointer; display:inline-flex; align-items:center; justify-content:center; flex-shrink:0;">
                    <svg width="18" height="18" viewBox="0 0 20 20" fill="none"><path d="M13 5l-5 5 5 5" stroke="#38bdf8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <div style="flex:1; font-size:11px; font-weight:900; color:#64748b; letter-spacing:1px; text-transform:uppercase; text-align:center;">
                    <span id="logs-title">LOGS</span>
                </div>
                <div style="width:44px; height:44px;"></div>
            </div>

            <div id="log-list"></div>
        </div>
    </div>
    <div id="calc-page" class="page" style="display: block; padding-top: 24px; padding-bottom: 24px;">
        <div class="card" style="margin-bottom: 24px;">
            <!-- Fleet Card Header (Kapak sayfası tarzında) -->
            <div class="fleet-card-header" onclick="window.location.href='index.html'" style="background: rgba(30, 41, 59, 0.6); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.08); width: 100%; padding: 14px 16px; border-radius: 18px; cursor: pointer; display: flex; align-items: center; gap: 18px; transition: transform 0.2s, background 0.2s; box-sizing: border-box; margin-bottom: 18px;">
                <div class="fleet-header-icon" style="display:flex; align-items:center; justify-content:center; width:46px; height:46px; border-radius:14px; background:rgba(56,189,248,0.12); flex-shrink:0;">
                    <svg class="animated-arrow" width="22" height="22" viewBox="0 0 20 20" fill="none"><path d="M13 5l-5 5 5 5" stroke="#38bdf8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </div>
                <div class="fleet-header-info" style="flex-grow: 1; padding-left: 4px;">
                    <h2 style="margin: 0; font-size: 17px; font-weight: 800; color: #38bdf8; letter-spacing: 0.5px;" class="fleet-title-row">
                        <span class="fleet-mini-logo" aria-hidden="true"><img id="fleet-brand-logo" class="brand-mini-logo" alt="" src="" loading="lazy"></span>
                        <span id="active-fleet">A320 FAMILY</span>
                    </h2>
                    <div id="fleet-limits" style="margin-top: 3px; font-size: 10px; color: #64748b; font-weight: 600; letter-spacing: 0.3px;">WING: 2 x 6,230 | CTR: 6,470 KG</div>
                    <div id="fleet-max" style="margin-top: 2px; font-size: 11px; color: #94a3b8; font-weight: 700;">MAX: 18,910 KG</div>
                </div>
            </div>
            <style>
            .fleet-card-header:active { transform: scale(0.98); background: rgba(56, 189, 248, 0.1); border-color: var(--primary); }
            .fleet-title-row { display: flex; align-items: center; gap: 8px; }
            .fleet-mini-logo { width: 20px; height: 20px; display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0; }
            .fleet-mini-logo img.brand-mini-logo { width: 18px; height: 18px; object-fit: contain; display: none; transform-origin: 50% 50%; }
            .fleet-mini-logo img.brand-mini-logo[data-brand="airbus"] { transform: scale(1.18); }
            .fleet-mini-logo img.brand-mini-logo[data-brand="boeing"] { transform: scale(0.92); }
            .animated-arrow { animation: arrow-hint 2600ms ease-in-out infinite; transform-origin: 50% 50%; }
            .animated-arrow path { stroke-width: 2; }
            @keyframes arrow-hint {
                0%, 100% { transform: scale(1); opacity: 0.85; }
                50% { transform: scale(1.08); opacity: 1; }
            }
            @keyframes arrow-stroke {
                0%, 100% { stroke-width: 2; }
                50% { stroke-width: 2.6; }
            }
            .animated-arrow path { animation: arrow-stroke 2600ms ease-in-out infinite; }
            @media (prefers-reduced-motion: reduce) {
                .animated-arrow, .animated-arrow path { animation: none !important; }
            }
            </style>
            <div class="action-row">
                <div style="display: flex; gap: 14px; width: 100%; margin-bottom: 18px;">
                    <button id="btn-logs" onclick="setView('logs')" class="reset-btn-amber" aria-label="Logs" title="Logs" style="background: rgba(56,189,248,0.12); border: 1.5px solid var(--primary); color: var(--primary); padding: 8px 12px; border-radius: 12px; font-size: 11px; font-weight: 900; cursor: pointer; text-transform: none; letter-spacing: 0.2px; line-height: 1.1; flex-shrink: 0; transition: background 0.2s, border 0.2s;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true" style="display:block;">
                            <path d="M3 5h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H3V5z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"></path>
                            <path d="M7 5v14" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"></path>
                        </svg>
                    </button>
                    <button id="btn-warn" onclick="showWarnings()" class="warning-btn" style="background: rgba(239,68,68,0.12); border: 1.5px solid var(--error); color: var(--error); padding: 8px 14px; border-radius: 12px; font-size: 11px; font-weight: 900; cursor: pointer; text-transform: uppercase; letter-spacing: 0.4px; line-height: 1.1; display: flex; align-items: center; gap: 6px; flex-grow: 1; transition: background 0.2s, border 0.2s;">⚠️ WARNINGS & PRECAUTIONS</button>
                    <button id="btn-reset" onclick="clearCalculator()" class="reset-btn-amber" aria-label="Reset calculator" title="Reset calculator" style="background: rgba(245,158,11,0.12); border: 1.5px solid var(--amber); color: var(--amber); padding: 8px 12px; border-radius: 12px; font-size: 11px; font-weight: 900; cursor: pointer; text-transform: none; letter-spacing: 0.2px; line-height: 1.1; flex-shrink: 0; transition: background 0.2s, border 0.2s;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true" style="display:block;">
                            <path d="M20 12a8 8 0 1 0-2.34 5.66" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"></path>
                            <path d="M20 4v6h-6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <div id="notice-area" class="notice-area">
                <div id="notice" class="notice hidden" role="status" aria-live="polite"><span class="notice-text"></span></div>
                <div id="notice-spacer" style="display:none;height:0px;visibility:hidden"></div>
            </div>

            <div class="input-capsule" style="background: rgba(30,41,59,0.55); border-radius: 28px; border: 1.5px solid rgba(100,116,139,0.18); box-shadow: 0 2px 16px 0 rgba(100,116,139,0.08); backdrop-filter: blur(8px); padding: 18px 10px 10px 10px; margin-bottom: 22px;">
            <!-- INPUTS BAŞLIĞI KALDIRILDI -->
            <div id="sec_block" class="input-group state-empty">
                <span id="lbl-block" class="group-label">Block Fuel</span>
                <div style="display:flex; align-items:center; gap:8px;"><button class="btn-step" onclick="stepValue('block_fuel', -10)">-</button><div class="input-with-unit"><input type="text" id="block_fuel" class="main-input" inputmode="numeric" pattern="[0-9]*" enterkeyhint="next" onkeydown="onFieldEnter(event,'block_fuel')" oninput="validateAll(true); updateUnitPosition(this)" onfocus="updateUnitPosition(this)" onblur="updateUnitPosition(this)"><span class="unit-corner">KG</span></div><button class="btn-step" onclick="stepValue('block_fuel', 10)">+</button></div>
                <div id="err_block" class="field-error"></div>
            </div>
            <div id="sec_actual" class="input-group state-empty">
                <span id="lbl-actual" class="group-label">Actual FOB</span>
                <div style="display:flex; align-items:center; gap:8px;"><button class="btn-step" onclick="stepValue('total_actual', -10)">-</button><div class="input-with-unit"><input type="text" id="total_actual" class="main-input" inputmode="numeric" pattern="[0-9]*" enterkeyhint="next" onkeydown="onFieldEnter(event,'total_actual')" oninput="validateAll(true); updateUnitPosition(this)" onfocus="updateUnitPosition(this)" onblur="updateUnitPosition(this)"><span class="unit-corner">KG</span></div><button class="btn-step" onclick="stepValue('total_actual', 10)">+</button></div>
                <div id="err_actual" class="field-error"></div>
                <div class="tank-grid">
                    <div class="tank-box"><span>LH</span><div class="tank-mid"><div class="tank-input-wrap"><input type="text" id="la" class="tank-input" inputmode="numeric" pattern="[0-9]*" tabindex="-1" onpointerdown="this.dataset.userActivated='1'" oninput="manualActualEntry(); updateTankUnitPosition(this)" onfocus="onTankFocus('la', this); clearZeroOnFocus(this); updateTankUnitPosition(this)" onblur="restoreZeroOnBlur(this); updateTankUnitPosition(this)" enterkeyhint="next" onkeydown="onTankEnter(event,'la')"><span class="tank-unit-corner">KG</span></div></div><div class="tank-step-row"><button class="btn-mini" onclick="stepTank('la',-10)">-</button><button class="btn-mini" onclick="stepTank('la',10)">+</button></div></div>
                    <div class="tank-box"><span>CENTER</span><div class="tank-mid"><div class="tank-input-wrap"><input type="text" id="ca" class="tank-input" inputmode="numeric" pattern="[0-9]*" tabindex="-1" onpointerdown="this.dataset.userActivated='1'" oninput="manualActualEntry(); updateTankUnitPosition(this)" onfocus="onTankFocus('ca', this); clearZeroOnFocus(this); updateTankUnitPosition(this)" onblur="restoreZeroOnBlur(this); updateTankUnitPosition(this)" enterkeyhint="next" onkeydown="onTankEnter(event,'ca')"><span class="tank-unit-corner">KG</span></div></div><div class="tank-step-row"><button class="btn-mini" onclick="stepTank('ca',-10)">-</button><button class="btn-mini" onclick="stepTank('ca',10)">+</button></div></div>
                    <div class="tank-box"><span>RH</span><div class="tank-mid"><div class="tank-input-wrap"><input type="text" id="ra" class="tank-input" inputmode="numeric" pattern="[0-9]*" tabindex="-1" onpointerdown="this.dataset.userActivated='1'" oninput="manualActualEntry(); updateTankUnitPosition(this)" onfocus="onTankFocus('ra', this); clearZeroOnFocus(this); updateTankUnitPosition(this)" onblur="restoreZeroOnBlur(this); updateTankUnitPosition(this)" enterkeyhint="next" onkeydown="onTankEnter(event,'ra')"><span class="tank-unit-corner">KG</span></div></div><div class="tank-step-row"><button class="btn-mini" onclick="stepTank('ra',-10)">-</button><button class="btn-mini" onclick="stepTank('ra',10)">+</button></div></div>
                </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: stretch;">
                <div class="input-group state-empty" id="box_density" style="margin-bottom: 0; display:flex; flex-direction:column;">
                    <span id="lbl-density" class="group-label">Density</span>
                    <div style="display:flex; justify-content:center;">
                        <div class="input-with-unit" style="width:100%;">
                            <input type="text" id="density" inputmode="decimal" enterkeyhint="next" onkeydown="onFieldEnter(event,'density')" oninput="handleDensityInput(this); updateUnitPosition(this)" onfocus="initDensity(this)" class="main-input" style="font-size:18px; height:42px; text-align:center;">
                            <span class="unit-corner">u</span>
                        </div>
                    </div>
                    <div id="err_density" class="field-error"></div>
                </div>
                <div id="box_temp" class="input-group state-empty" style="margin-bottom: 0;">
                    <span id="lbl-temp" class="group-label">Temp</span>
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                        <div class="input-with-unit">
                            <input type="text" id="temp_c" inputmode="decimal" pattern="-?[0-9]*[.,]?[0-9]*" enterkeyhint="next" onkeydown="onFieldEnter(event,'temp_c')" oninput="calcTemp('c'); updateUnitPosition(this)" onfocus="updateUnitPosition(this)" onblur="updateUnitPosition(this)" class="main-input" style="font-size:18px; height:42px;">
                            <span class="unit-corner">°C</span>
                        </div>
                        <div class="input-with-unit">
                            <input type="text" id="temp_f" inputmode="decimal" pattern="-?[0-9]*[.,]?[0-9]*" enterkeyhint="done" onkeydown="onFieldEnter(event,'temp_f')" oninput="calcTemp('f'); updateUnitPosition(this)" onfocus="updateUnitPosition(this)" onblur="updateUnitPosition(this)" class="main-input" style="font-size:18px; height:42px;">
                            <span class="unit-corner">°F</span>
                        </div>
                    </div>
                    <div id="err_temp" class="field-error"></div>
                </div>
            </div>
            </div>
            <!-- OUTPUTS BAŞLIĞI KALDIRILDI -->
            <div id="sec_result" class="dashboard result-disabled" aria-disabled="true">
                <div class="tank-grid" style="margin-top:0;">
                    <div class="tank-box"><span>LH</span><div class="tank-mid"><div class="tank-input-wrap"><div id="lt" class="tgt-val">0</div><span class="tank-unit-corner tank-unit-tgt">KG</span></div></div><div class="tank-step-row"><button id="btn-lt-minus" class="btn-mini" onclick="smartAdjust('lt',-10)">-</button><button id="btn-lt-plus" class="btn-mini" onclick="smartAdjust('lt',10)">+</button></div></div>
                    <div class="tank-box"><span>CENTER</span><div class="tank-mid"><div class="tank-input-wrap"><div id="ct" class="tgt-val">0</div><span class="tank-unit-corner tank-unit-tgt">KG</span></div></div><div class="tank-step-row"><button id="btn-ct-minus" class="btn-mini" onclick="smartAdjust('ct',-20)">-</button><button id="btn-ct-plus" class="btn-mini" onclick="smartAdjust('ct',20)">+</button></div></div>
                    <div class="tank-box"><span>RH</span><div class="tank-mid"><div class="tank-input-wrap"><div id="rt" class="tgt-val">0</div><span class="tank-unit-corner tank-unit-tgt">KG</span></div></div><div class="tank-step-row"><button id="btn-rt-minus" class="btn-mini" onclick="smartAdjust('rt',-10)">-</button><button id="btn-rt-plus" class="btn-mini" onclick="smartAdjust('rt',10)">+</button></div></div>
                </div>
                <div class="uplift-container">
                    <div id="uplift-title" class="uplift-title">UPLIFT</div>
                    <div class="uplift-split">
                        <div>
                        <script>
                            (function(){
                                const inputsSelector = '.main-input, .tank-input';
                                const inputs = () => Array.from(document.querySelectorAll(inputsSelector));

                                function getVisibleNoticeRect(){
                                    try{
                                        const notice = document.getElementById('notice');
                                        if(!notice) return null;
                                        if(notice.classList && notice.classList.contains('hidden')) return null;
                                        if(notice.offsetParent === null) return null; // not rendered
                                        return notice.getBoundingClientRect();
                                    }catch(e){ return null; }
                                }

                                function focusScroll(el){
                                    // wait for virtual keyboard to appear on mobile; moderate delay
                                    setTimeout(()=>{
                                                if(!el) return;
                                                const viewportH = window.innerHeight || document.documentElement.clientHeight;
                                                const basePadding = Math.min(80, Math.round(viewportH * 0.12));
                                                const extraMargin = 8;

                                                // If available, prefer the whole input-group container so the label and frame stay visible
                                                const container = el.closest && el.closest('.input-group') ? el.closest('.input-group') : el;
                                                let cRect = null;
                                                try{ cRect = container.getBoundingClientRect(); }catch(e){ cRect = el.getBoundingClientRect(); }

                                                // Read notice rect (use bottom for precise visible position)
                                                const nRect = getVisibleNoticeRect();
                                                const desiredViewportTop = nRect ? Math.round(nRect.bottom) + extraMargin : basePadding;

                                                const id = el.id || '';
                                                // Align the container top under the notice (keeps title & frame visible)
                                                try{
                                                    const target = window.scrollY + cRect.top - desiredViewportTop;
                                                    // Special-case small jumps for certain fields to avoid large page jumps
                                                    const isSpecial = (id === 'density' || id === 'temp_c' || id === 'temp_f' || id === 'total_actual');
                                                    if (isSpecial) {
                                                        const maxDelta = 90;
                                                        const curr = window.scrollY;
                                                        const desiredScroll = Math.max(0, Math.round(target));
                                                        const safeBottom = viewportH - 60;
                                                        const ensureBottomScroll = Math.max(0, window.scrollY + cRect.bottom - safeBottom);
                                                        let chosen = desiredScroll;
                                                        if (ensureBottomScroll > chosen) chosen = ensureBottomScroll;
                                                        if (chosen > curr + maxDelta) chosen = curr + maxDelta;
                                                        if (chosen < curr - maxDelta) chosen = Math.max(0, curr - maxDelta);
                                                        window.scrollTo({ top: Math.max(0, Math.round(chosen)), behavior: 'smooth' });
                                                    } else {
                                                        window.scrollTo({ top: Math.max(0, Math.round(target)), behavior: 'smooth' });
                                                    }
                                                }catch(e){
                                                    // fallback to element-based alignment
                                                    try{ const r = el.getBoundingClientRect(); window.scrollTo({ top: Math.max(0, Math.round(window.scrollY + r.top - desiredViewportTop)), behavior: 'smooth' }); }catch(_){}
                                                }

                                                // ensure next input is also visible; if not, nudge more upward
                                                const arr = inputs();
                                                const idx = arr.indexOf(el);
                                                if(idx >= 0 && idx < arr.length - 1){
                                                    const next = arr[idx + 1];
                                                    const nRect2 = next.getBoundingClientRect();
                                                    if(nRect2.bottom > viewportH - 60){
                                                        const extra = nRect2.bottom - (viewportH - 60);
                                                        window.scrollTo({ top: Math.max(0, window.scrollY + extra + 12), behavior: 'smooth' });
                                                    }
                                                }
                                    }, 300);
                                }

                                document.addEventListener('focusin', (e)=>{
                                    const el = e.target;
                                    if(el && el.matches && el.matches(inputsSelector)){
                                        try{ const g = el.closest && el.closest('.input-group'); if(g) g.classList.add('focused'); }catch(_){}
                                        // If a suppression flag is set (programmatic move e.g. density->temp), skip scrolling once
                                        if(window._suppressNextFocusScroll){ try{ window._suppressNextFocusScroll = false; }catch(_){}; return; }
                                        focusScroll(el);
                                    }
                                }, true);

                                document.addEventListener('focusout', (e)=>{
                                    const el = e.target;
                                    if(el && el.matches && el.matches(inputsSelector)){
                                        try{ const g = el.closest && el.closest('.input-group'); if(g) g.classList.remove('focused'); }catch(_){}
                                    }
                                }, true);

                                // Also handle touchstart/pointerdown to anticipate focus on iOS where focus happens after keyboard
                                document.addEventListener('pointerdown', (e)=>{
                                    const el = e.target.closest ? e.target.closest(inputsSelector) : null;
                                    if(el) focusScroll(el);
                                }, {passive: true});

                                // Keep spacer synced with the (now fixed) notice height so
                                // layout doesn't jump and automatic scrolling can offset correctly.
                                (function syncNoticeSpacer(){
                                    const notice = document.getElementById('notice');
                                    const spacer = document.getElementById('notice-spacer');
                                    if(!notice || !spacer) return;

                                    function update(){
                                        try{
                                            if(notice.classList && notice.classList.contains('hidden')){
                                                spacer.style.display = 'none';
                                                spacer.style.height = '0px';
                                                spacer.style.visibility = 'hidden';
                                            } else {
                                                const h = notice.offsetHeight || 48;
                                                spacer.style.display = 'block';
                                                spacer.style.height = h + 'px';
                                                spacer.style.visibility = 'visible';
                                            }
                                        }catch(e){}
                                    }

                                    window.addEventListener('resize', update, {passive:true});
                                    // watch for hide/show via class changes
                                    try{
                                        const mo = new MutationObserver(update);
                                        mo.observe(notice, { attributes: true, attributeFilter: ['class', 'style'] });
                                    }catch(e){}

                                    // initial sync
                                    setTimeout(update, 40);
                                    document.addEventListener('DOMContentLoaded', update);
                                })();
                                // Position the fixed notice so that when the page is at top
                                // it visually sits above the Block Fuel group; when the user
                                // scrolls down it pins to top (12px). Keep spacer synced.
                                (function positionNoticeAboveBlock(){
                                    const notice = document.getElementById('notice');
                                    const spacer = document.getElementById('notice-spacer');
                                    const blockGroup = document.getElementById('sec_block');
                                    if(!notice || !spacer || !blockGroup) return;

                                    const extra = 8;

                                    function syncSpacer(){
                                        try{
                                            if(notice.classList && notice.classList.contains('hidden')){
                                                spacer.style.display = 'none';
                                                spacer.style.height = '0px';
                                                spacer.style.visibility = 'hidden';
                                            } else {
                                                const h = notice.offsetHeight || 48;
                                                spacer.style.display = 'block';
                                                spacer.style.height = h + 'px';
                                                spacer.style.visibility = 'visible';
                                            }
                                        }catch(e){}
                                    }

                                    let anchorScrollY = null;
                                    function position(){
                                        try{
                                            syncSpacer();
                                            const noticeH = notice.offsetHeight || 48;
                                            // Compute block group's document Y using offsetTop for reliability
                                            const blockDocY = (function(n){ let y=0; while(n){ y += n.offsetTop || 0; n = n.offsetParent; } return y; })(blockGroup);
                                            // desired top relative to viewport = block's doc Y - noticeH - extra - window.scrollY
                                            const desiredTopViewport = Math.round(blockDocY - noticeH - extra - window.scrollY);
                                            // compute anchor only once or when null
                                            if(anchorScrollY === null){
                                                // when scrollY reaches this value, we pin notice to 12px
                                                anchorScrollY = Math.max(0, blockDocY - noticeH - extra - 12);
                                            }

                                            if(window.scrollY >= anchorScrollY){
                                                // pinned at top
                                                notice.style.top = '12px';
                                            } else {
                                                // place above block group (but don't go above 12px)
                                                const t = Math.max(12, desiredTopViewport);
                                                notice.style.top = t + 'px';
                                            }
                                        }catch(e){}
                                    }

                                    // respond to viewport changes and DOM mutations
                                    window.addEventListener('resize', ()=>{ position(); }, {passive:true});
                                    window.addEventListener('scroll', ()=>{ position(); }, {passive:true});
                                    window.addEventListener('pageshow', ()=>{ setTimeout(position, 40); });
                                    try{
                                        const mo = new MutationObserver(()=>{ position(); });
                                        mo.observe(notice, { attributes: true, attributeFilter: ['class', 'style'] });
                                        mo.observe(blockGroup, { attributes: true, childList: true, subtree: true });
                                    }catch(e){}

                                    // run multiple times shortly after load to account for rendering delays
                                    setTimeout(position, 40);
                                    setTimeout(position, 200);
                                    setTimeout(position, 600);
                                    document.addEventListener('DOMContentLoaded', position);
                                })();
                            })();
                        </script>
                            <div class="uplift-unit">KG</div>
                            <div id="res_kg" class="val-num" style="color:var(--warning)">0</div>
                        </div>
                        <div class="uplift-cell-right">
                            <div class="uplift-unit">LTR</div>
                            <div id="res_lit" class="val-num" style="color:var(--primary)">0</div>
                        </div>
                    </div>
                </div>
                <button id="save-main-btn" class="save-btn" onclick="saveRecord()" disabled style="margin-top:12px; margin-bottom:0;">SAVE & VIEW RECEIPT</button>
                
            </div>
        </div>
    </div>
    <div id="receipt-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.92); z-index:100; align-items:center; justify-content:center; padding:20px; -webkit-backdrop-filter:blur(10px);">
        <div class="receipt-content" style="background:white; color:black; width:100%; max-width:340px; border-radius:8px; padding:25px; font-family:'Courier New', monospace;">
            <h3 id="receipt-title" style="text-align:center; border-bottom:2px dashed #000; padding-bottom:12px; margin-top:0">REFUEL RECEIPT</h3>
            <div id="r-details" style="font-size:13px; line-height:1.6; display:block;"></div>
            <iframe id="receipt-iframe" style="display:none; width:100%; height:520px; border:none; background:#fff"></iframe>
            <div id="pdf-viewer" style="display:none; width:100%; height:520px; overflow:auto; text-align:center;">
                <canvas id="pdf-canvas" style="max-width:100%; height:auto; display:block; margin:0 auto"></canvas>
            </div>
            <!-- Fener butonu kaldırıldı (özellik web-only projede desteklenmiyor) -->
            <button id="receipt-close" onclick="(function(){var r=document.getElementById('receipt-modal'); if(r){r.style.display='none'; r.style.pointerEvents='none';}})()" style="width:100%; background:#000; color:#fff; border:none; padding:18px; margin-top:12px; font-weight:800; border-radius:6px; cursor:pointer">CLOSE</button>
        </div>
    </div>
    <div id="warning-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.92); z-index:100; align-items:center; justify-content:center; padding:20px; -webkit-backdrop-filter:blur(10px);">
        <div class="warning-content" style="background:#1e293b; color:white; width:100%; max-width:340px; border-radius:20px; padding:25px; border:2px solid var(--error); max-height:78vh; display:flex; flex-direction:column; overflow:hidden;">
            <h3 id="warn-title" style="color:var(--error); margin-top:0; text-align:center">YAKIT İKMALİ UYARILAR & ÖNLEMLER</h3>
            <div id="warn-desc" style="font-size:11px; color:#94a3b8; line-height:1.5; margin:-6px 0 10px; text-align:center;">
                Bu liste genel bir hatırlatmadır. Uçak tipiniz için <b>AMM/FCOM/Operatör prosedürleri</b> ve panel/placard limitleri daima önceliklidir.
            </div>
            <div class="warning-scroll" style="overflow:auto; -webkit-overflow-scrolling:touch; padding-right:4px; margin:0;">
                <ul id="warn-list" style="font-size:12px; padding-left:20px; line-height:1.55; margin:0;">
                    <li><b>Yetkilendirme:</b> Doğru uçak, doğru sefer ve doğru yakıt tipini (grade) teyit edin. Şüphede işlemi durdurup amire/crew’a danışın.</li>
                    <li><b>Alan emniyeti:</b> No smoking/açık alev yok. Uçak çevresi emniyete alın, koniler/chock’lar yerinde olsun. Uygun yangın söndürücü hazır bulunsun.</li>
                    <li><b>Grounding/Bonding:</b> Yakıt ikmali başlamadan <b>bonding/ground</b> bağlantılarını kurun; bağlantılar sökülmeden önce ikmali bitirin. Kapak/panel açmadan önce statik riski kontrol edin.</li>
                    <li><b>İletişim:</b> Ground–cockpit iletişimi net olsun. “STOP/ABORT” komutu ve acil durdurma prosedürü herkesçe bilinsin.</li>
                    <li><b>Hava koşulları:</b> Yakında yıldırım/şimşek, yoğun statik, yakıt buharı birikimi veya güvenli olmayan rüzgâr şartlarında ikmali durdurun.</li>
                    <li><b>APU/Engine/GPU:</b> Operatör prosedürlerine uygun konfigürasyonu sağlayın. “Hot refuel” gerekiyorsa ek önlemleri uygulayın (ekipman/yangın nöbeti/alan kontrolü).</li>
                    <li><b>Yakıt kalitesi:</b> Yakıt fişi/sertifika, filtre, numune ve kontaminasyon (su/partikül) kontrolü yapın. <b>Density</b> değerini fişten doğrulayın; uygulamaya gerçek değer girin.</li>
                    <li><b>Basınçlı ikmal:</b> Nozzle/adapter tam kilitli olsun. Basınç/flow limitleri için <b>panel placard/AMM</b> referans alın. Anormal titreşim/ses/kaçak varsa derhal durdurun.</li>
                    <li><b>Sızıntı & havalandırma:</b> Kanat altı/vent bölgelerini gözleyin. Vent/overfill belirtisinde ikmali kesin; sebep giderilmeden devam etmeyin.</li>
                    <li><b>Denge & sıra:</b> <b>WING FIRST</b> prensibini izleyin: kanatlar dengeli doldurulmalı, center genelde kanatlardan sonra. Sol/sağ tanklar arasında asimetri yaratmayın.</li>
                    <li><b>Limitler:</b> Seçili model için tank limitleri (wing/center) ve toplam kapasiteyi aşmayın. Şüphede sistem hesaplarına değil, <b>AMM/placard</b> değerlerine dönün.</li>
                    <li><b>Spill/Acil durum:</b> Dökülmede ikmali durdurun, acil stop’u kullanın, alanı izole edin ve raporlayın. Yakıt buharı/yangın riskine karşı prosedürü uygulayın.</li>
                    <li><b>İkmal sonrası:</b> Bonding’i en son sökün. Kapak/panel kapalı ve emniyette olsun. Son miktarları (total + tank) crew ile teyit edin ve kayıtları tamamlayın.</li>
                </ul>
            </div>
            <button id="warn-ok" type="button" style="width:100%; background:var(--error); color:#fff; border:none; padding:15px; margin-top:12px; font-weight:800; border-radius:12px; cursor:pointer; flex-shrink:0;">ANLADIM</button>
        </div>
    </div>

<script>
// Parametreleri URL'den al
function getParam(name) {
    const url = new URL(window.location.href);
    return url.searchParams.get(name);
}

function setView(view) {
    const url = new URL(window.location.href);
    const v = String(view || '').trim();
    if (v) url.searchParams.set('view', v);
    else url.searchParams.delete('view');
    try {
        history.replaceState(null, '', url.toString());
    } catch (e) {
        // Fallback: if history manipulation fails, keep working without URL update.
    }
    applyViewMode();
}

function applyViewMode() {
    const view = String(getParam('view') || '').trim().toLowerCase();
    const logsPage = document.getElementById('logs-page');
    const calcPage = document.getElementById('calc-page');
    if (!logsPage || !calcPage) return;

    const isLogs = (view === 'logs');
    logsPage.style.display = isLogs ? 'block' : 'none';
    calcPage.style.display = isLogs ? 'none' : 'block';
    if (isLogs) {
        try { renderLogs(); } catch (e) {}
    }
}


// UYARI: Uygulama arayüzündeki limitler KG cinsinden çalışır.
// Tank ve total limitler tek kaynaktan (tankLimitsKg) çekilir.
const LW_PARAM = parseInt(getParam('wing')) || 0;
const LC_PARAM = parseInt(getParam('ctr')) || 0;
let LW = LW_PARAM;
let LC = LC_PARAM;
let fleet = getParam('fleet') || '';
const TANK_KEY = (getParam('tankkey') || '').trim() || fleet;
let NO_LIMITS = (String(getParam('nolimits') || '').trim() === '1');
const REG_PARAM_RAW = (getParam('reg') || '').trim();
const MAX_LIMIT_PLACEHOLDER = 900000;
let TANK_LIMITS_KG = null;

function normalizeReg(value) {
    const v = String(value || '').trim().toUpperCase();
    // accept strict TC-ABC style
    if (/^TC-[A-Z0-9]{3}$/.test(v)) return v;
    return '';
}

function getRegistration() {
    const fromUrl = normalizeReg(REG_PARAM_RAW);
    if (fromUrl) {
        try { localStorage.setItem('refuel_assist_tail', fromUrl); } catch (e) {}
        return fromUrl;
    }
    try {
        const fromLs = normalizeReg(localStorage.getItem('refuel_assist_tail') || '');
        return fromLs;
    } catch (e) {
        return '';
    }
}

function isDensityOk(dV) { return (typeof dV === 'number' && dV >= 0.6 && dV <= 0.9); }

function renderFleetLimitsHeader() {
    document.getElementById('active-fleet').innerText = (fleet || '').toUpperCase();
    if (NO_LIMITS) {
        document.getElementById('fleet-limits').innerText = 'WING: 2 x — | CTR: — KG';
        return;
    }
    document.getElementById('fleet-limits').innerText = 'WING: 2 x ' + (LW || 0).toLocaleString() + ' | CTR: ' + (LC || 0).toLocaleString() + ' KG';
}

function refreshLimitsFromDensity() {
    // Öncelik: JSON içindeki KG placard limitleri (en güncel ve en doğru kaynak).
    if (TANK_LIMITS_KG) {
        const wingKgRaw = Math.max(
            0,
            Math.max(TANK_LIMITS_KG.leftWingFuelKg || 0, TANK_LIMITS_KG.rightWingFuelKg || 0)
        );
        const ctrKgRaw = Math.max(0, TANK_LIMITS_KG.centerFuelKg || 0);

        // Uygulama 10 KG adım kullandığı için limitleri 10'luk aşağı yuvarla.
        const wingKg = Math.floor(wingKgRaw / 10) * 10;
        const ctrKg = Math.floor(ctrKgRaw / 10) * 10;

        // Güvenlik: URL paramı verilmişse ve daha kısıtlayıcıysa onu uygula.
        LW = (LW_PARAM > 0) ? Math.min(LW_PARAM, wingKg) : wingKg;
        LC = (LC_PARAM > 0) ? Math.min(LC_PARAM, ctrKg) : ctrKg;
        return;
    }

    // Limit bulunamazsa: URL paramları ile devam et (geri uyumluluk)
    LW = LW_PARAM;
    LC = LC_PARAM;
}

async function initTankCaps() {
    // tankLimitsKg: kapak sayfasıyla aynı limit kaynağı
    try {
        if (typeof window.fetchTankLimitsKg === 'function' && TANK_KEY) {
            const limits = await window.fetchTankLimitsKg(TANK_KEY);
            if (limits) TANK_LIMITS_KG = limits;
        }
    } catch (e) {}

    // Eğer KG limit bulunduysa NO_LIMITS paramını geçersiz kıl (tek ortak kaynaktan limit uygula)
    if (TANK_LIMITS_KG) NO_LIMITS = false;

    refreshLimitsFromDensity();
    renderFleetLimitsHeader();
    renderCapacityRef();
    try { validateAll(false); } catch (e) {}
}

window.addEventListener('DOMContentLoaded', initTankCaps);

// --- i18n (TR/EN) ---
const LANG_STORAGE_KEY = 'refuel_assist_lang';
let currentLang = 'tr';
let lastReceiptLog = null;
let warnListTrHtml = '';

const I18N = {
    tr: {
        title: 'Refuel Assist v7.3.46 - Hesaplama',
        logs_title: 'KAYITLAR',
        btn_logs: 'KAYITLAR',
        btn_warn: '⚠️ UYARILAR & ÖNLEMLER',
        btn_reset: 'SIFIRLA',
        lbl_block: 'Blok Yakıt',
        lbl_actual: 'İkmal Öncesi Yakıt (Fuel On Board)',
        lbl_density: 'Yoğunluk',
        lbl_temp: 'Sıcaklık',
        uplift: 'İKMAL',
        save: 'KAYDET & FİŞİ GÖR',
        receipt_title: 'YAKIT FİŞİ',
        close: 'KAPAT',
        recent_logs: 'SON KAYITLAR',
        clear_all: 'TÜMÜNÜ SİL',
        confirm_clear_logs: 'Tüm geçmiş silinsin mi?',
        label_date: 'TARİH',
        label_fleet: 'FİLO',
        label_density: 'YOĞUNLUK',
        label_temp: 'SICAKLIK',
        label_block: 'BLOK YAKIT',
        label_actual: 'İKMAL ÖNCESİ YAKIT (FUEL ON BOARD)',
        label_target: 'HEDEF DEĞERLER',
        label_uplift_kg: 'İKMAL KG',
        label_uplift_ltr: 'İKMAL LTR',
        warn_title: 'YAKIT İKMALİ UYARILAR & ÖNLEMLER',
        warn_desc: 'Bu liste genel bir hatırlatmadır. Uçak tipiniz için <b>AMM/FCOM/Operatör prosedürleri</b> ve panel/placard limitleri daima önceliklidir.',
        warn_ok: 'ANLADIM',
        temp_invalid: 'Sıcaklık değeri gerçekçi aralıkta değil (-60°C ile +60°C). °C değerini düzeltin; °F otomatik hesaplanır.',
        block_step: 'Blok Yakıt 10 kg adımıyla girilmeli. 10’un katı bir değer yazın (örn. 3500).',
        actual_step: 'Mevcut yakıt değerleri 10 kg adımıyla girilmeli. (Toplam ve tanklar 10’un katı olmalı.)',
        actual_gt_block: 'Mevcut yakıt (ikmal öncesi), Block’tan büyük görünüyor. Mevcut ≤ Block olmalı (gerekirse tank değerlerini düşürün).',
        density_range: 'Yoğunluk değeri aralık dışı (0.600–0.900). Yakıt fişindeki density değerini kontrol edip tekrar girin.',
        density_digits: 'Yoğunluk üç ondalık hane olarak girilmelidir (örn. 0.800).',
        prompt_block: 'Blok Yakıt girin. Sefer öncesi olması gereken toplam yakıtı temsil eder.',
        prompt_actual: 'İkmal öncesi (mevcut) yakıt için toplam değeri yazabilir veya tank değerlerini girebilirsiniz. Tanklardan girerseniz toplam otomatik hesaplanır.',
        prompt_density: 'Yoğunluk girin (örn. 0.800). Litre hesabı için gereklidir ve 0.600–0.900 aralığında olmalı.',
        prompt_temp: 'Sıcaklık için °C veya °F değerini girin. Diğer değer otomatik hesaplanır.',

        guide_btn: 'KILAVUZ',
        guide_title: 'Hesaplama Kılavuzu',
        guide_steps_html: [
            '<li><b>Blok Yakıt:</b> Sefer öncesi olması gereken toplam yakıt (KG).</li>',
            '<li><b>İkmal Öncesi (FOB):</b> Toplam yazabilir veya LH/CENTER/RH tanklarını girerek otomatik toplatabilirsiniz.</li>',
            '<li><b>Yoğunluk & Sıcaklık:</b> Litre hesabı ve fiş bilgisi için girilir (density 0.600–0.900).</li>',
            '<li><b>Sonuç:</b> Hedef tank değerleri (LH/CENTER/RH) ve <b>İKMAL</b> (KG/LTR) oluşur.</li>',
            '<li><b>Kaydet & Fiş:</b> <b>"KAYDET & FİŞİ GÖR"</b> ile kaydedin; fiş otomatik açılır.</li>',
            '<li><b>Kayıtlar:</b> <b>"KAYITLAR"</b> ile geçmişe gidin; kayda tıklayınca fiş açılır; <b>×</b> ile silin; <b>"TÜMÜNÜ SİL"</b> ile temizleyin.</li>'
        ].join(''),
        guide_foot: 'İpucu: LOGS sayfası cihazda (localStorage) saklanır.'
        ,
        sw_update_ready: 'Yeni sürüm hazır.',
        sw_update_progress: 'GÜNCELLENİYOR...',
        sw_update_reload: 'GÜNCELLE'
    },
    en: {
        title: 'Refuel Assist v7.3.46 - Calculator',
        logs_title: 'LOGS',
        btn_logs: 'LOGS',
        btn_warn: '⚠️ WARNINGS & PRECAUTIONS',
        btn_reset: 'RESET',
        lbl_block: 'Block Fuel',
        lbl_actual: 'Fuel On Board',
        lbl_density: 'Density',
        lbl_temp: 'Temp',
        uplift: 'UPLIFT',
        save: 'SAVE & VIEW RECEIPT',
        receipt_title: 'REFUEL RECEIPT',
        close: 'CLOSE',
        recent_logs: 'RECENT LOGS',
        clear_all: 'CLEAR ALL',
        confirm_clear_logs: 'Delete all history?',
        label_date: 'DATE',
        label_fleet: 'FLEET',
        label_density: 'DENSITY',
        label_temp: 'TEMP',
        label_block: 'BLOCK FUEL',
        label_actual: 'FUEL ON BOARD',
        label_target: 'TARGET VALUES',
        label_uplift_kg: 'UPLIFT KG',
        label_uplift_ltr: 'UPLIFT LTR',
        warn_title: 'REFUELING WARNINGS & PRECAUTIONS',
        warn_desc: 'This is a general reminder. For your aircraft type, <b>AMM/FCOM/operator procedures</b> and panel/placard limits always take priority.',
        warn_ok: 'GOT IT',
        temp_invalid: 'Temperature is outside realistic range (-60°C to +60°C). Fix °C; °F is auto-calculated.',
        block_step: 'Block Fuel must be entered in 10 kg steps. Use a multiple of 10 (e.g., 3500).',
        actual_step: 'Fuel On Board values must be entered in 10 kg steps (total and tanks must be multiples of 10).',
        actual_gt_block: 'Fuel On Board (pre-refuel) seems higher than Block. Fuel On Board ≤ Block (reduce tank values if needed).',
        density_range: 'Density is out of range (0.600–0.900). Verify from the fuel slip and re-enter.',
        density_digits: 'Density must be three decimal places (e.g. 0.800).',
        prompt_block: 'Enter Block Fuel. It represents required total fuel before departure.',
        prompt_actual: 'For Fuel On Board (pre-refuel), enter total or tank values. If you enter tanks, total is calculated automatically.',
        prompt_density: 'Enter Density (e.g., 0.800). Needed for liters and must be within 0.600–0.900.',
        prompt_temp: 'Enter temperature in °C or °F. The other value is calculated automatically.',

        guide_btn: 'GUIDE',
        guide_title: 'Calculator Guide',
        guide_steps_html: [
            '<li><b>Block Fuel:</b> Required total fuel before departure (KG).</li>',
            '<li><b>Fuel On Board:</b> Enter total or LH/CENTER/RH tanks to auto-calculate the total.</li>',
            '<li><b>Density & Temp:</b> Used for liters and receipt details (density 0.600–0.900).</li>',
            '<li><b>Result:</b> Target tank values (LH/CENTER/RH) and <b>UPLIFT</b> (KG/LTR) are shown.</li>',
            '<li><b>Save & receipt:</b> Use <b>"SAVE & VIEW RECEIPT"</b>; receipt opens automatically.</li>',
            '<li><b>Logs:</b> Go to <b>"LOGS"</b>; tap an entry to open receipt; delete with <b>×</b>; clear all with <b>"CLEAR ALL"</b>.</li>'
        ].join(''),
        guide_foot: 'Tip: Logs are stored locally on the device (localStorage).'
        ,
        sw_update_ready: 'A new version is ready.',
        sw_update_progress: 'UPDATING...',
        sw_update_reload: 'RELOAD'
    }
};

function getLang() {
    const raw = (localStorage.getItem(LANG_STORAGE_KEY) || '').toLowerCase();
    return raw === 'en' ? 'en' : 'tr';
}

function setLang(lang) {
    const next = (lang === 'en') ? 'en' : 'tr';
    localStorage.setItem(LANG_STORAGE_KEY, next);
    applyLang(next);
}

function t(key) {
    const dict = I18N[currentLang] || I18N.tr;
    return dict[key] ?? (I18N.tr[key] ?? key);
}

function applyLang(lang) {
    currentLang = (lang === 'en') ? 'en' : 'tr';
    document.documentElement.lang = currentLang;
    document.title = t('title');

    const btnTr = document.getElementById('lang-tr');
    const btnEn = document.getElementById('lang-en');
    if (btnTr && btnEn) {
        btnTr.classList.toggle('active', currentLang === 'tr');
        btnEn.classList.toggle('active', currentLang === 'en');
    }

    const btnLogs = document.getElementById('btn-logs');
    const btnGuide = document.getElementById('btn-guide');
    const btnWarn = document.getElementById('btn-warn');
    const btnReset = document.getElementById('btn-reset');
    if (btnLogs) {
        btnLogs.setAttribute('title', t('btn_logs'));
        btnLogs.setAttribute('aria-label', t('btn_logs'));
        if (!btnLogs.querySelector('svg')) btnLogs.textContent = t('btn_logs');
    }
    if (btnGuide) btnGuide.textContent = t('guide_btn');
    if (btnWarn) btnWarn.textContent = t('btn_warn');
    if (btnReset) {
        // keep icon if present; update accessible label/title
        btnReset.setAttribute('title', t('btn_reset'));
        btnReset.setAttribute('aria-label', t('btn_reset'));
        // only set visible text if there is no SVG icon inside
        if (!btnReset.querySelector('svg')) btnReset.textContent = t('btn_reset');
    }

    const logsTitle = document.getElementById('logs-title');
    if (logsTitle) logsTitle.textContent = t('logs_title');

    const lblBlock = document.getElementById('lbl-block');
    const lblActual = document.getElementById('lbl-actual');
    const lblDensity = document.getElementById('lbl-density');
    const lblTemp = document.getElementById('lbl-temp');
    if (lblBlock) lblBlock.textContent = t('lbl_block');
    if (lblActual) lblActual.textContent = t('lbl_actual');
    if (lblDensity) lblDensity.textContent = t('lbl_density');
    if (lblTemp) lblTemp.textContent = t('lbl_temp');

    const upliftTitle = document.getElementById('uplift-title');
    if (upliftTitle) upliftTitle.textContent = t('uplift');

    const saveBtn = document.getElementById('save-main-btn');
    if (saveBtn) saveBtn.textContent = t('save');

    const receiptTitle = document.getElementById('receipt-title');
    const receiptClose = document.getElementById('receipt-close');
    if (receiptTitle) receiptTitle.textContent = t('receipt_title');
    if (receiptClose) receiptClose.textContent = t('close');

    const warnTitle = document.getElementById('warn-title');
    const warnDesc = document.getElementById('warn-desc');
    const warnOk = document.getElementById('warn-ok');
    if (warnTitle) warnTitle.textContent = t('warn_title');
    if (warnDesc) warnDesc.innerHTML = t('warn_desc');
    if (warnOk) warnOk.textContent = t('warn_ok');

    // Ensure the warning modal can be closed reliably (attach via JS rather than inline onclick)
    try {
        if (warnOk) {
            warnOk.addEventListener('click', function () {
                try {
                    var r = document.getElementById('warning-modal');
                    if (r) {
                        r.style.display = 'none';
                        r.style.pointerEvents = 'none';
                    }
                } catch (e) {}
            });
        }
    } catch (e) {}

    const guideTitle = document.getElementById('guide-title');
    const guideSteps = document.getElementById('guide-steps');
    const guideFoot = document.getElementById('guide-foot');
    if (guideTitle) guideTitle.textContent = t('guide_title');
    if (guideSteps) guideSteps.innerHTML = t('guide_steps_html');
    if (guideFoot) guideFoot.textContent = t('guide_foot');

    // sw-update banner removed; no DOM elements to update

    const warnList = document.getElementById('warn-list');
    if (warnList) {
        if (currentLang === 'en') {
            warnList.innerHTML = [
                '<li><b>Authorization:</b> Confirm correct aircraft, flight and fuel grade. If in doubt, stop and ask supervisor/crew.</li>',
                '<li><b>Area safety:</b> No smoking/open flames. Secure the aircraft area; cones/chocks in place. Suitable fire extinguisher ready.</li>',
                '<li><b>Grounding/Bonding:</b> Connect bonding/ground before refueling and keep connected until refueling is complete. Manage static risk before opening panels.</li>',
                '<li><b>Communication:</b> Keep clear ground–cockpit communication. Ensure everyone knows STOP/ABORT and emergency stop procedures.</li>',
                '<li><b>Weather:</b> Stop refueling if lightning risk, heavy static, vapor accumulation, or unsafe wind conditions exist.</li>',
                '<li><b>APU/Engine/GPU:</b> Configure per operator procedure. If hot refuel is required, apply additional precautions (equipment/fire watch/area control).</li>',
                '<li><b>Fuel quality:</b> Check documentation, filtration, sampling and contamination (water/particles). Verify <b>density</b> from the fuel slip and enter the real value.</li>',
                '<li><b>Pressure refuel:</b> Ensure nozzle/adapter is fully locked. Respect placard/AMM pressure and flow limits. Stop immediately for abnormal vibration/noise/leaks.</li>',
                '<li><b>Leak/venting:</b> Monitor wing/vent areas. Stop for venting/overfill indications; do not continue until resolved.</li>',
                '<li><b>Balance & sequence:</b> Follow <b>WING FIRST</b>: keep wings balanced; center typically after wings. Avoid left/right asymmetry.</li>',
                '<li><b>Limits:</b> Do not exceed tank limits (wing/center) and total capacity. When in doubt, follow <b>AMM/placard</b> values over app calculations.</li>',
                '<li><b>Spill/Emergency:</b> Stop refueling, use emergency stop, isolate area and report. Follow procedures for vapor/fire risk.</li>',
                '<li><b>After refuel:</b> Disconnect bonding last. Ensure caps/panels closed and secured. Confirm final quantities with crew and complete records.</li>'
            ].join('');
        } else {
            if (warnListTrHtml) warnList.innerHTML = warnListTrHtml;
        }
    }

    try {
        const isReceiptOpen = document.getElementById('receipt-modal')?.style?.display === 'flex';
        if (isReceiptOpen && lastReceiptLog) openReceipt(lastReceiptLog);
    } catch (e) {}

    try { renderLogs(); } catch (e) {}
    try { validateAll(false); } catch (e) {}
    try { renderCapacityRef(); } catch (e) {}
}

function openGuide() {
    const modal = document.getElementById('guide-modal');
    if (!modal) return;
    modal.style.display = 'flex';
}

function closeGuide() {
    const modal = document.getElementById('guide-modal');
    if (!modal) return;
    modal.style.display = 'none';
}

window.addEventListener('DOMContentLoaded', () => {
    const guideModal = document.getElementById('guide-modal');
    if (guideModal) {
        guideModal.addEventListener('click', (e) => {
            if (e.target === guideModal) closeGuide();
        });
    }
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeGuide();
    });
});

document.getElementById('lang-tr')?.addEventListener('click', () => setLang('tr'));
document.getElementById('lang-en')?.addEventListener('click', () => setLang('en'));
try { warnListTrHtml = document.getElementById('warn-list')?.innerHTML || ''; } catch (e) { warnListTrHtml = ''; }
applyLang(getLang());

// Kapak sayfasında dil değişince (diğer sekmelerde) anında güncelle
window.addEventListener('storage', (e) => {
    try {
        if (e && e.key === LANG_STORAGE_KEY) applyLang(getLang());
    } catch (err) {}
});

// BFCache/back-forward dönüşlerinde güncel dili tekrar uygula
window.addEventListener('pageshow', () => {
    try { applyLang(getLang()); } catch (err) {}
    try { applyViewMode(); } catch (err) {}
});

// Marka logosunu fleet'e göre ayarla
(function setFleetLogo() {
    const img = document.getElementById('fleet-brand-logo');
    if (!img) return;

    const f = (fleet || '').toUpperCase();
    let src = '';
    let brand = '';
    if (f.includes('AIRBUS') || f.includes('A319') || f.includes('A320') || f.includes('A321') || f.includes('A330') || f.includes('A350')) { src = 'assets/airbus.svg'; brand = 'airbus'; }
    else if (f.includes('BOEING') || f.includes('B737') || f.includes('B777') || f.includes('B787')) { src = 'assets/boeing.svg'; brand = 'boeing'; }

    if (!src) {
        img.style.display = 'none';
        img.src = '';
        img.removeAttribute('data-brand');
        return;
    }

    img.src = src;
    img.setAttribute('data-brand', brand);
    img.style.display = 'block';
})();

function renderCapacityRef() {
    const maxEl = document.getElementById('fleet-max');
    if (!maxEl) return;

    // Tek kaynak: tankLimitsKg. totalFuelKg varsa onu, yoksa LW/LC toplamını göster.
    const totalKg = (TANK_LIMITS_KG && typeof TANK_LIMITS_KG.totalFuelKg === 'number') ? TANK_LIMITS_KG.totalFuelKg : null;
    const maxCapKg = (typeof totalKg === 'number' && totalKg > 0) ? totalKg : ((LW * 2) + LC);

    if (NO_LIMITS && (!Number.isFinite(maxCapKg) || maxCapKg <= 0)) {
        maxEl.innerText = 'MAX CAP: —';
        return;
    }
    maxEl.innerText = 'MAX CAP: ' + Math.max(0, Math.round(maxCapKg)).toLocaleString() + ' KG';
}

// Fleet bilgilerini güncelle
if (NO_LIMITS) {
    document.getElementById('fleet-limits').innerText = 'WING: 2 x — | CTR: — KG';
    // NO_LIMITS modunda limit zorlanmaz (limit tablosu yoksa).
    renderCapacityRef();
} else {
    document.getElementById('fleet-limits').innerText = 'WING: 2 x ' + LW.toLocaleString() + ' | CTR: ' + LC.toLocaleString() + ' KG';
    renderCapacityRef();
}
// Orijinal index.html'den alınan hesaplama ve event fonksiyonları
function stepValue(id, v) { let el=document.getElementById(id); el.value=Math.max(0, (parseFloat(el.value)||0)+v); validateAll(true); updateUnitPosition(el); }
function stepTank(id, v) {
    let el = document.getElementById(id);
    let limit = (id === 'ca') ? LC : LW;
    const maxCap = getEffectiveMaxCapKg();
    if (Number.isFinite(maxCap)) limit = Math.min(limit, maxCap);
    el.value = Math.max(0, Math.min(limit, (parseFloat(el.value) || 0) + v));
    manualActualEntry();
}
function manualActualEntry() {
    let bV = Math.max(0, parseFloat(document.getElementById('block_fuel').value) || 0);
    let l = parseFloat(document.getElementById('la').value) || 0;
    let c = parseFloat(document.getElementById('ca').value) || 0;
    let r = parseFloat(document.getElementById('ra').value) || 0;
    const maxCap = getEffectiveMaxCapKg();
    if (Number.isFinite(maxCap) && maxCap > 0) {
        l = Math.min(maxCap, l);
        c = Math.min(maxCap, c);
        r = Math.min(maxCap, r);
    }
    if (!NO_LIMITS) {
        l = Math.min(LW, l); r = Math.min(LW, r); c = Math.min(LC, c);
    }
    let currentTotal = l + c + r;
    const capLimit = (Number.isFinite(maxCap) && maxCap > 0) ? maxCap : Number.POSITIVE_INFINITY;
    const effectiveLimit = (bV > 0) ? Math.min(bV, capLimit) : capLimit;
    if (currentTotal > effectiveLimit && effectiveLimit > 0 && Number.isFinite(effectiveLimit)) {
        let overflow = currentTotal - effectiveLimit;
        if (c >= overflow) { c -= overflow; } 
        else { overflow -= c; c = 0; let half = overflow / 2; l -= half; r -= half; }
    }
    document.getElementById('la').value = Math.max(0, l);
    document.getElementById('ra').value = Math.max(0, r);
    document.getElementById('ca').value = Math.max(0, c);
    document.getElementById('total_actual').value = Math.max(0, l + c + r);
    validateAll(false);

    // Otomatik değişen tankların unit pozisyonlarını da güncelle
    ['la', 'ca', 'ra'].forEach(id => updateTankUnitPosition(document.getElementById(id)));
}
function showWarnings() {
    try {
        var m = document.getElementById('warning-modal');
        if (m) {
            m.style.display = 'flex';
            m.style.pointerEvents = 'auto';
            try { var sc = m.querySelector('.warning-scroll'); if (sc) sc.scrollTop = 0; } catch (e) {}
        }
    } catch (e) {}
}
function forceDensityCaretRight(el) {
    if (!el) return;
    const v = (el.value || '');
    const pos = Math.max(2, v.length);
    try { el.setSelectionRange(pos, pos); } catch (e) {}
}
function initDensity(el) {
    if (!el.value || el.value === '') el.value = '0.';
    setTimeout(() => {
        forceDensityCaretRight(el);
        updateUnitPosition(el);
    }, 0);
}
function shakeDensity() {
    const el = document.getElementById('density');
    el.classList.remove('shake');
    void el.offsetWidth; // Reflow trigger
    el.classList.add('shake');
}
function handleDensityInput(el) {
    let val = el.value;
    let cursorPos = (typeof el.selectionStart === 'number') ? el.selectionStart : val.length;
    let prevLen = val.length;
    
    // Tamamen boş veya sadece 0 ise
    if (val === '' || val === '0') {
        el.value = '0.';
        el.setSelectionRange(2, 2);
        shakeDensity();
        validateAll(false);
        return;
    }
    
    // 0. silinmeye çalışıldıysa
    if (val.length < 2 || !val.startsWith('0.')) {
        let nums = val.replace(/[^0-9]/g, '').slice(0, 3);
        el.value = '0.' + nums;
        el.setSelectionRange(2, 2);
        shakeDensity();
        validateAll(false);
        return;
    }
    
    // 0. sonrasını kontrol et - sadece rakam ve max 3 hane
    let afterDot = val.slice(2).replace(/[^0-9]/g, '').slice(0, 3);
    el.value = '0.' + afterDot;
    
    // Cursor pozisyonunu ayarla
    let newCursor = Math.max(2, Math.min(cursorPos, el.value.length));
    el.setSelectionRange(newCursor, newCursor);
    
    validateAll(false);
}

// Density input'ta (özellikle mobilde) sol tarafa tıklayınca caret 0.'ın soluna düşebiliyor.
// Değer değişmediği için `input` event tetiklenmediğinden handleDensityInput çalışmıyor.
// Bu yüzden pointer/click ile caret'i her zaman 0.'ın sağına zorluyoruz.
(function bindDensityCaretLock() {
    const el = document.getElementById('density');
    if (!el) return;

    const apply = () => {
        if (!el.value || el.value === '') el.value = '0.';
        forceDensityCaretRight(el);
    };

    const scheduleApply = () => {
        // Tarayıcının kendi caret yerleştirmesinden sonra tekrar uygula
        setTimeout(apply, 0);
        requestAnimationFrame(apply);
    };

    ['pointerdown', 'mousedown', 'touchstart', 'click'].forEach(evt => {
        el.addEventListener(evt, scheduleApply, { passive: true });
    });
    el.addEventListener('focus', scheduleApply);
})();
// Handle Enter/Next from virtual keyboard and move focus in desired order.
function onFieldEnter(ev, fieldId) {
    if (!ev) return;
    // Accept Enter key or virtual keyboard 'Enter'
    if (ev.key && ev.key !== 'Enter') return;
    try { ev.preventDefault(); } catch (e) {}

    // Temperature navigation/finish rules:
    // - If C is correctly entered and Enter pressed -> close keyboard and show dashboard
    // - If C is NOT correctly entered and Enter pressed -> move focus to F
    // - If F has a value and Enter pressed -> close keyboard and show dashboard
    const tempCEl = document.getElementById('temp_c');
    const tempFEl = document.getElementById('temp_f');
    const cRaw = tempCEl ? (tempCEl.value || '').trim() : '';
    const fRaw = tempFEl ? (tempFEl.value || '').trim() : '';
    const cNum = parseFloat(cRaw);
    const isCValid = (cRaw !== '' && !isNaN(cNum) && cNum >= -60 && cNum <= 60);
    const isFFilled = (fRaw !== '');

    if (fieldId === 'temp_c') {
        if (isCValid) { showDashboardFully(); return; }
        // c not valid -> move focus to F
        if (tempFEl) { tempFEl.focus(); return; }
        return;
    }
    if (fieldId === 'temp_f') {
        if (isFFilled || isCValid) { showDashboardFully(); return; }
        // otherwise, move back to C for correction
        if (tempCEl) { tempCEl.focus(); return; }
        return;
    }
    // If user pressed Enter on total_actual, skip ACT tank inputs and go to density
    if (fieldId === 'total_actual') {
        const d = document.getElementById('density');
        if (d) { d.focus(); try { forceDensityCaretRight(d); } catch (e) {} }
        return;
    }

    const order = ['block_fuel','total_actual','density','temp_c','temp_f'];
    const idx = order.indexOf(fieldId);
    if (idx === -1) return;
    const nextId = order[idx + 1];
    if (!nextId) return;
    const nextEl = document.getElementById(nextId);
    if (nextEl) {
        // If moving from density -> temp, suppress the automatic focus scroll once
        if (fieldId === 'density' && (nextId === 'temp_c' || nextId === 'temp_f')) {
            try{ window._suppressNextFocusScroll = true; }catch(e){}
        }
        nextEl.focus();
        if (nextId === 'density') try { forceDensityCaretRight(nextEl); } catch (e) {}
    }
}

// When user finishes input flow (e.g. presses 'done' on temp_f), blur and reveal dashboard fully
function getNoticeBottom(){
    try{
        const notice = document.getElementById('notice');
        if(!notice) return 0;
        if(notice.classList && notice.classList.contains('hidden')) return 0;
        if(notice.offsetParent === null) return 0;
        return Math.round(notice.getBoundingClientRect().bottom);
    }catch(e){return 0;}
}
function showDashboardFully(){
    try{ if(document.activeElement && document.activeElement.blur) document.activeElement.blur(); }catch(e){}
    setTimeout(()=>{
        const sec = document.getElementById('sec_result');
        if(!sec) return;
        const rect = sec.getBoundingClientRect();
        const noticeBottom = getNoticeBottom();
        const desired = window.scrollY + rect.top - (noticeBottom ? noticeBottom + 6 : 0);
        window.scrollTo({ top: Math.max(0, desired), behavior: 'smooth' });
    }, 220);
}
// Tank-specific focus handling: detect explicit user tap and allow Next navigation
window._tankUserMode = false;
window._currentTankId = '';
function onTankFocus(id, el) {
    // If element was explicitly tapped, mark tank user mode
    try {
        if (el && el.dataset && el.dataset.userActivated === '1') {
            window._tankUserMode = true;
            window._currentTankId = id;
        } else {
            // if focus came programmatically, do not enable tank mode
            // keep previous tank mode state
        }
        // clear dataset flag
        if (el && el.dataset) delete el.dataset.userActivated;
    } catch (e) {}
}

function onTankEnter(ev, id) {
    if (!ev) return;
    if (ev.key && ev.key !== 'Enter') return;
    try { ev.preventDefault(); } catch (e) {}

    // Only handle tank navigation if user explicitly focused a tank
    if (!window._tankUserMode) return;

    const seq = ['la','ca','ra'];
    const idx = seq.indexOf(id);
    if (idx === -1) return;
    if (idx < seq.length - 1) {
        const next = document.getElementById(seq[idx+1]);
        if (next) { next.focus(); window._currentTankId = seq[idx+1]; }
        return;
    }
    // if last tank (ra) -> focus density and exit tank mode
    const d = document.getElementById('density');
    if (d) { d.focus(); try { forceDensityCaretRight(d); } catch (e) {} }
    window._tankUserMode = false;
    window._currentTankId = '';
}
function getDensityValue() {
    const raw = document.getElementById('density').value;
    if (!raw || raw === '0.' || raw === '') return 0;
    return parseFloat(raw) || 0;
}

function getEffectiveMaxCapKg() {
    if (NO_LIMITS) {
        return Number.POSITIVE_INFINITY;
    }
    if (TANK_LIMITS_KG && typeof TANK_LIMITS_KG.totalFuelKg === 'number' && TANK_LIMITS_KG.totalFuelKg > 0) {
        // 10 KG adımına uyum için aşağı yuvarla
        return Math.floor(TANK_LIMITS_KG.totalFuelKg / 10) * 10;
    }
    return (LW * 2) + LC;
}
function updateUnitPosition(input) {
    const wrapper = input.closest('.input-with-unit');
    if (!wrapper) return;
    const suffix = wrapper.querySelector('.unit-corner');
    if (!suffix) return;
    const text = input.value || '';
    const inputWidth = input.offsetWidth;
    const isFocused = document.activeElement === input;
    
    if (text === '' && !isFocused) {
        // Always anchor to right-bottom even when empty
        suffix.style.left = 'auto';
        suffix.style.right = '10px';
        suffix.style.transform = 'translateY(2px)';
        return;
}
}
function updateAllUnits() {
    document.querySelectorAll('.input-with-unit input').forEach(input => updateUnitPosition(input));
    document.querySelectorAll('.tank-input').forEach(input => updateTankUnitPosition(input));
    updateTgtUnitPositions();
}
function updateTankUnitPosition(input) {
    const wrapper = input.closest('.tank-input-wrap');
    if (!wrapper) return;
    const suffix = wrapper.querySelector('.tank-unit-corner');
    if (!suffix) return;
    const text = input.value || '';
    const inputWidth = wrapper.offsetWidth;
    const isFocused = document.activeElement === input;
    
    if (text === '' && !isFocused) {
        // Always anchor to right-bottom even when empty
        suffix.style.left = 'auto';
        suffix.style.right = '8px';
        suffix.style.transform = 'translateY(2px)';
        return;
}

}

function clearZeroOnFocus(input) {
    if (!input) return;
    const v = (input.value || '').trim();
    if (v === '0') input.value = '';
}

function restoreZeroOnBlur(input) {
    if (!input) return;
    const v = (input.value || '').trim();
    if (v === '') input.value = '0';
}

function updateTgtUnitPositions() {
    ['lt', 'ct', 'rt'].forEach(id => {
        const el = document.getElementById(id);
        const wrapper = el ? el.closest('.tank-input-wrap') : null;
        const unit = wrapper ? wrapper.querySelector('.tank-unit-corner') : null;
        if (!el || !unit) return;
        
        const text = el.innerText || '0';
        const wrapperWidth = wrapper.offsetWidth;
        
        // anchor target unit to right-bottom inside wrapper (always)
        unit.style.transform = 'translateY(2px)';
        unit.style.left = 'auto';
        unit.style.right = '8px';
    });
}
function calcTemp(s) { const c = document.getElementById('temp_c'), f = document.getElementById('temp_f'); let v; if(s==='c'){ v = parseFloat(c.value); f.value = c.value!==''?Math.round((v*9/5)+32):''; updateUnitPosition(f); } else { v = Math.round((parseFloat(f.value)-32)*5/9); c.value = f.value!==''? v : ''; updateUnitPosition(c); } validateAll(false); }
function clearCalculator() {
    ['block_fuel','total_actual','la','ca','ra','density','temp_c','temp_f'].forEach(id => {
        if (document.getElementById(id)) document.getElementById(id).value = '';
    });
    try { sessionStorage.removeItem('calc_state_v1'); } catch (e) {}
    validateAll(true);
    updateAllUnits();
}

function setNotice(messages, tone = 'error') {
    const el = document.getElementById('notice');
    if (!el) return;
    const textEl = el.querySelector('.notice-text');
    if (!messages || messages.length === 0) {
        el.classList.add('hidden');
        el.style.removeProperty('--notice-accent');
        if (textEl) textEl.textContent = '';
        else el.textContent = '';
        return;
    }

    el.style.setProperty('--notice-accent', tone === 'warn' ? 'var(--amber)' : 'var(--error)');
    el.classList.remove('hidden');
    const text = messages.join(' • ');
    if (textEl) textEl.textContent = text;
    else el.textContent = text;
}

function validateAll(auto = false) {
    let bV = Math.max(0, parseFloat(document.getElementById('block_fuel').value) || 0);
    let aV = Math.max(0, parseFloat(document.getElementById('total_actual').value) || 0);
    let dV = getDensityValue();
    let tV = parseFloat(document.getElementById('temp_c').value);
    const bRaw = (document.getElementById('block_fuel').value || '').trim();
    const aRaw = (document.getElementById('total_actual').value || '').trim();
    const laV = parseFloat(document.getElementById('la').value) || 0;
    const caV = parseFloat(document.getElementById('ca').value) || 0;
    const raV = parseFloat(document.getElementById('ra').value) || 0;
    // Yoğunluk değiştikçe (veya geçerli oldukça) limitleri L->KG çevrilmiş şekilde tazele
    refreshLimitsFromDensity();
    renderFleetLimitsHeader();
    const maxCap = getEffectiveMaxCapKg();
    const secB = document.getElementById('sec_block'), secA = document.getElementById('sec_actual'), boxD = document.getElementById('box_density'), boxT = document.getElementById('box_temp');
    const secR = document.getElementById('sec_result');
    let errB = "", errA = "", errD = "", errT = "";
    
    // Yardımcı fonksiyon: input state güncelle
    function setInputState(el, state) {
        el.classList.remove('state-empty', 'state-error', 'state-valid');
        el.classList.add('state-' + state);
    }
    
    // TEMP validasyonu
    const tempCRaw = document.getElementById('temp_c').value.trim();
    const tempFRaw = document.getElementById('temp_f').value.trim();
    const isTempFilled = tempCRaw !== '';
    const isTempInvalid = !isNaN(tV) && (tV < -60 || tV > 60);
    if (isTempInvalid) { errT = t('temp_invalid'); setInputState(boxT, 'error'); }
    else if (!isTempFilled) { setInputState(boxT, 'empty'); }
    else { setInputState(boxT, 'valid'); }
    document.getElementById('err_temp').innerText = errT;
    
    if (Number.isFinite(maxCap) && bV > maxCap) {
        bV = Math.floor(maxCap / 10) * 10;
        document.getElementById('block_fuel').value = bV;
    }

    if (Number.isFinite(maxCap) && aV > maxCap) {
        aV = Math.floor(maxCap / 10) * 10;
        document.getElementById('total_actual').value = aV;
    }
    
    // BLOCK FUEL validasyonu
    const isBlockFilled = (bRaw !== "") && bV > 0;
    if (bV % 10 !== 0 && bV > 0) { errB = t('block_step'); setInputState(secB, 'error'); }
    else if (!isBlockFilled) { setInputState(secB, 'empty'); }
    else { setInputState(secB, 'valid'); }
    
    // ACTUAL FOB validasyonu
    const isActualFilled = (aRaw !== "") && aV > 0;
    if ((aV % 10 !== 0 && aV > 0) || (laV % 10 !== 0) || (caV % 10 !== 0) || (raV % 10 !== 0)) { errA = t('actual_step'); setInputState(secA, 'error'); } 
    else if (aV > bV && bV > 0) { errA = t('actual_gt_block'); setInputState(secA, 'error'); } 
    else if (!isActualFilled) { setInputState(secA, 'empty'); }
    else { setInputState(secA, 'valid'); }
    
    // DENSITY validasyonu
    const densityRaw = document.getElementById('density').value.trim();
    const densityPattern = /^0\.\d{3}$/; // exactly three digits after decimal
    const isDensityFormatOk = densityPattern.test(densityRaw);
    const isDensityFilled = isDensityFormatOk && dV > 0;
    if (dV > 0 && (dV < 0.6 || dV > 0.9)) {
        errD = t('density_range'); setInputState(boxD, 'error');
    } else if (densityRaw !== '' && densityRaw !== '0.' && !isDensityFormatOk) {
        errD = t('density_digits'); setInputState(boxD, 'error');
    } else if (!isDensityFilled) {
        setInputState(boxD, 'empty');
    } else { setInputState(boxD, 'valid'); }
    document.getElementById('err_block').innerText = errB; document.getElementById('err_actual').innerText = errA; document.getElementById('err_density').innerText = errD;

    let topMessage = '';
    let topTone = 'warn';
    // Öncelik sırası: Block -> Actual -> Density -> Temp
    if (errB) { topMessage = errB; topTone = 'error'; }
    else if (!isBlockFilled) topMessage = t('prompt_block');
    else if (errA) { topMessage = errA; topTone = 'error'; }
    else if (!isActualFilled) topMessage = t('prompt_actual');
    else if (errD) { topMessage = errD; topTone = 'error'; }
    else if (!isDensityFilled) topMessage = t('prompt_density');
    else if (errT) { topMessage = errT; topTone = 'error'; }
    else {
        if (!topMessage && !isTempFilled) topMessage = t('prompt_temp');
    }

    setNotice(topMessage ? [topMessage] : [], topTone);

    if(auto && !errB && !errA) {
        const distribute = (val) => {
            // When NO_LIMITS, default to wing split (center 0) and let user adjust.
            if (NO_LIMITS) {
                let half = Math.round((val / 2) / 10) * 10;
                return {l: half, r: Math.max(0, val - half), c: 0};
            }
            if (val <= LW * 2) { let half = Math.round((val / 2) / 10) * 10; return {l: half, r: val - half, c: 0}; } 
            else { return {l: LW, r: LW, c: val - (LW * 2)}; }
        };
        let act = distribute(aV), tgt = distribute(bV);
        document.getElementById('la').value = act.l; document.getElementById('ra').value = act.r; document.getElementById('ca').value = act.c;
        document.getElementById('lt').innerText = tgt.l; document.getElementById('rt').innerText = tgt.r; document.getElementById('ct').innerText = tgt.c;
        // Tank unit pozisyonlarını güncelle
        ['la', 'ca', 'ra'].forEach(id => updateTankUnitPosition(document.getElementById(id)));
    }
    let currentTgtTotal = parseInt(document.getElementById('lt').innerText) + parseInt(document.getElementById('rt').innerText) + parseInt(document.getElementById('ct').innerText);
    let resK = Math.max(0, currentTgtTotal - aV);
    document.getElementById('res_kg').innerText = resK.toLocaleString();
    let litVal = (dV >= 0.6 && dV <= 0.9 && resK > 0) ? Math.round(resK / dV) : 0;
    document.getElementById('res_lit').innerText = litVal.toLocaleString();
    document.getElementById('save-main-btn').disabled = (resK <= 0 || dV < 0.6 || dV > 0.9 || errB !== "" || errA !== "" || isTempInvalid || !isTempFilled);
    const isDensityOk = (dV >= 0.6 && dV <= 0.9);
    const isTempOk = isTempFilled && !isTempInvalid;
    const isCalcReady = isBlockFilled && isActualFilled && isDensityOk && isTempOk && errB === "" && errA === "";
    if (secR) {
        secR.classList.toggle('result-disabled', !isCalcReady);
        secR.classList.toggle('result-ready', isCalcReady);
        secR.setAttribute('aria-disabled', (!isCalcReady).toString());
    }
    updateButtons();
    updateTgtUnitPositions();
    renderCapacityRef();

    // Input state'ini hafif throttled şekilde sakla (geri dönüşlerde stabilite için)
    scheduleSaveCalcState();
}
function updateButtons() {
    let lt = parseInt(document.getElementById('lt').innerText);
    let ct = parseInt(document.getElementById('ct').innerText);
    let rt = parseInt(document.getElementById('rt').innerText);
    document.getElementById('btn-lt-plus').disabled = (lt >= LW || (ct <= 0 && rt <= 0));
    document.getElementById('btn-lt-minus').disabled = (lt <= 0 || (ct >= LC && rt >= LW));
    document.getElementById('btn-ct-plus').disabled = (ct >= LC || (lt <= 0 && rt <= 0));
    document.getElementById('btn-ct-minus').disabled = (ct <= 0 || (lt >= LW && rt >= LW));
    document.getElementById('btn-rt-plus').disabled = (rt >= LW || (lt <= 0 && ct <= 0));
    document.getElementById('btn-rt-minus').disabled = (rt <= 0 || (lt >= LW && ct >= LC));
}
function smartAdjust(tank, delta) {
    let lt = parseInt(document.getElementById('lt').innerText);
    let ct = parseInt(document.getElementById('ct').innerText);
    let rt = parseInt(document.getElementById('rt').innerText);
    let effectiveDelta = delta; 
    if (tank === 'lt') {
        let move = effectiveDelta > 0 ? Math.min(effectiveDelta, LW - lt) : Math.max(effectiveDelta, -lt);
        if (move > 0) { if (ct >= move) { ct -= move; lt += move; } else { let rem = move - ct; if (rt >= rem) { lt += move; ct = 0; rt -= rem; } } } 
        else { let sC = LC - ct; if (sC >= Math.abs(move)) { ct += Math.abs(move); lt += move; } else { let rem = Math.abs(move) - sC; if (LW - rt >= rem) { lt += move; ct = LC; rt += rem; } } }
    } else if (tank === 'ct') {
        let move = effectiveDelta > 0 ? Math.min(effectiveDelta, LC - ct) : Math.max(effectiveDelta, -ct);
        if (move > 0) { let h = move / 2; if (lt >= h && rt >= h) { lt -= h; rt -= h; ct += move; } } 
        else { let h = Math.abs(move) / 2; if (LW - lt >= h && LW - rt >= h) { lt += h; rt += h; ct += move; } }
    } else if (tank === 'rt') {
        let move = effectiveDelta > 0 ? Math.min(effectiveDelta, LW - rt) : Math.max(effectiveDelta, -rt);
        if (move > 0) { if (ct >= move) { ct -= move; rt += move; } else { let rem = move - ct; if (lt >= rem) { rt += move; ct = 0; lt -= rem; } } } 
        else { let sC = LC - ct; if (sC >= Math.abs(move)) { ct += Math.abs(move); rt += move; } else { let rem = Math.abs(move) - sC; if (LW - lt >= rem) { rt += move; ct = LC; lt += rem; } } }
    }
    document.getElementById('lt').innerText = lt; document.getElementById('ct').innerText = ct; document.getElementById('rt').innerText = rt;
    validateAll(false);
}
function saveRecord() {
    const densVal = getDensityValue();
    const locale = (getLang() === 'en') ? 'en-GB' : 'tr-TR';
    const rec = {
        id: Date.now(),
        fleet: fleet,
        reg: getRegistration(),
        time: new Date().toLocaleTimeString(locale, {hour:'2-digit', minute:'2-digit'}),
        date: new Date().toLocaleDateString(locale),
        block: document.getElementById('block_fuel').value,
        dens: densVal.toFixed(3),
        tempC: document.getElementById('temp_c').value,
        act_total: document.getElementById('total_actual').value,
        act_l: document.getElementById('la').value,
        act_c: document.getElementById('ca').value,
        act_r: document.getElementById('ra').value,
        tgt_l: document.getElementById('lt').innerText,
        tgt_c: document.getElementById('ct').innerText,
        tgt_r: document.getElementById('rt').innerText,
        kg: document.getElementById('res_kg').innerText,
        lt: document.getElementById('res_lit').innerText
    };
    let logs = JSON.parse(localStorage.getItem('logs_v6') || '[]');
    logs.unshift(rec);
    localStorage.setItem('logs_v6', JSON.stringify(logs));
    renderLogs(); openReceipt(rec);
}

// Generate a debug PDF (overlays + grid) without requiring URL params
function generateDebugReceipt() {
    const densVal = getDensityValue();
    const locale = (getLang() === 'en') ? 'en-GB' : 'tr-TR';
    const rec = {
        id: Date.now(),
        fleet: fleet,
        reg: getRegistration(),
        time: new Date().toLocaleTimeString(locale, {hour:'2-digit', minute:'2-digit'}),
        date: new Date().toLocaleDateString(locale),
        block: document.getElementById('block_fuel').value,
        dens: densVal.toFixed(3),
        tempC: document.getElementById('temp_c').value,
        act_total: document.getElementById('total_actual').value,
        act_l: document.getElementById('la').value,
        act_c: document.getElementById('ca').value,
        act_r: document.getElementById('ra').value,
        tgt_l: document.getElementById('lt').innerText,
        tgt_c: document.getElementById('ct').innerText,
        tgt_r: document.getElementById('rt').innerText,
        kg: document.getElementById('res_kg').innerText,
        lt: document.getElementById('res_lit').innerText
    };
    // Use HTML fallback receipt (same as save & view)
    openReceipt(rec);
}

// Generate a debug PDF (overlays + grid) without requiring URL params
// debug helper removed in final build
function renderLogs() {
    const list = document.getElementById('log-list');
    if (!list) return;
    let logs = JSON.parse(localStorage.getItem('logs_v6') || '[]');
    if(logs.length === 0) { list.innerHTML = ''; return; }
    list.innerHTML = `<div style="display:flex; justify-content:space-between; align-items:center; margin:15px 0 10px"><span style="font-size:11px; font-weight:900; color:#64748b; letter-spacing:1px">${escapeHtml(t('recent_logs'))}</span><button id="btn-clear-logs" type="button" onclick="clearAllLogs()" style="color:var(--error); background:none; border:none; font-size:10px; font-weight:800; cursor:pointer">${escapeHtml(t('clear_all'))}</button></div>`;
    logs.forEach(log => {
        const div = document.createElement('div'); div.className = 'log-item';
        const safeId = Number(log.id) || 0;
        const fleetText = escapeHtml(log.fleet);
        const kgText = escapeHtml(log.kg);
        const timeText = escapeHtml(log.time);
        div.innerHTML = `<div onclick="openReceiptById(${safeId})" style="flex-grow:1; display:flex; justify-content:space-between; align-items:center"><span><b>${fleetText}</b></span><span><b style="color:var(--warning)">${kgText} KG</b> <small style="opacity:0.5; margin-left:8px">${timeText}</small></span></div><button class="del-log" onclick="deleteLog(${safeId})">×</button>`;
        list.appendChild(div);
    });
    // Attach clear-all handler programmatically to avoid relying on inline onclick attributes
    try {
        const btn = document.getElementById('btn-clear-logs');
        if (btn) {
            btn.addEventListener('click', function (e) {
                e.preventDefault();
                clearAllLogs();
            });
        }
    } catch (e) {}
}
function deleteLog(id) { let logs = JSON.parse(localStorage.getItem('logs_v6') || '[]'); logs = logs.filter(l => l.id !== id); localStorage.setItem('logs_v6', JSON.stringify(logs)); renderLogs(); }
function clearAllLogs() { if(confirm(t('confirm_clear_logs'))) { localStorage.removeItem('logs_v6'); renderLogs(); } }
function openReceiptById(id) { let logs = JSON.parse(localStorage.getItem('logs_v6') || '[]'); let log = logs.find(l => l.id === id); if(log) openReceipt(log); }
function escapeHtml(value) {
    return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}
let _lastReceiptBlobUrl = null;

function loadPdfLib() {
    return new Promise((resolve, reject) => {
        if (window.PDFLib) return resolve(window.PDFLib);
        // Try local copy first (assets/pdf-lib.min.js), then CDN fallback
        const tryLoad = (src) => new Promise((res, rej) => {
            const s = document.createElement('script');
            s.src = src;
            s.onload = () => res(window.PDFLib);
            s.onerror = () => rej(new Error('load failed'));
            document.head.appendChild(s);
        });

        tryLoad('./assets/pdf-lib.min.js')
            .then(resolve)
            .catch(() => {
                // fallback to CDN
                tryLoad('https://unpkg.com/pdf-lib/dist/pdf-lib.min.js')
                    .then(resolve)
                    .catch(() => reject(new Error('pdf-lib yüklenemedi (yerel ve CDN denemesi başarısız)')));
            });
    });
}

<<<<<<< HEAD
// Try rendering PDF bytes using PDF.js (inline). Returns true if rendered.
async function renderPdfWithPdfJs(pdfBytes) {
    if (!pdfBytes) return false;
    // Try local copy first (assets/pdfjs), then CDN fallback
    if (!window.pdfjsLib) {
        const tryLoad = async (src, workerSrc) => {
            await new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
            if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;
            }
        };
        try {
            await tryLoad('./assets/pdfjs/pdf.min.js', './assets/pdfjs/pdf.worker.min.js');
        } catch (e) {
            try {
                await tryLoad('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js', 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js');
            } catch (e2) {
                return false;
            }
        }
    }

    try {
        const loadingTask = window.pdfjsLib.getDocument({ data: pdfBytes });
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);
        const scale = 1.2;
        const viewport = page.getViewport({ scale });
        let canvas = document.getElementById('pdf-canvas');
        if (!canvas) return false;
        const ctx = canvas.getContext('2d');
        canvas.width = Math.round(viewport.width);
        canvas.height = Math.round(viewport.height);
        const renderTask = page.render({ canvasContext: ctx, viewport });
        await renderTask.promise;
        let viewer = document.getElementById('pdf-viewer');
        if (viewer) {
            // Move viewer to top-level so modal overlay/styling doesn't interfere
            try {
                viewer.style.display = 'block';
                viewer.style.position = 'fixed';
                viewer.style.left = '50%';
                viewer.style.top = '50%';
                viewer.style.transform = 'translate(-50%, -50%)';
                viewer.style.width = '92%';
                viewer.style.maxWidth = '720px';
                viewer.style.height = 'auto';
                viewer.style.maxHeight = '82vh';
                viewer.style.background = '#fff';
                viewer.style.zIndex = '999999';
                viewer.style.boxShadow = '0 10px 40px rgba(0,0,0,0.6)';
                viewer.style.borderRadius = '8px';
                // detach and append to body
                if (viewer.parentNode !== document.body) document.body.appendChild(viewer);
                // add a close button to the viewer so it can be dismissed
                let vclose = document.getElementById('pdf-viewer-close');
                if (!vclose) {
                    vclose = document.createElement('button');
                    vclose.id = 'pdf-viewer-close';
                    vclose.textContent = 'Kapat';
                    vclose.style.cssText = 'position:absolute; right:8px; top:8px; z-index:1000000; background:#111; color:#fff; border:none; padding:6px 10px; border-radius:6px; cursor:pointer; font-weight:700';
                    vclose.addEventListener('click', function(){
                        try { viewer.style.display = 'none'; if (viewer.parentNode === document.body) document.body.removeChild(viewer); } catch(e){}
                    });
                    viewer.appendChild(vclose);
                }
            } catch (e) {}
        }
        return true;
    } catch (e) {
        return false;
    }
}

=======
// Inline PDF.js rendering removed — use overlay-only behavior.
async function renderPdfWithPdfJs(pdfBytes) {
    // Disabled: prefer consistent overlay rendering for all PDFs.
    return false;
}

// Show a generated PDF blob/url as a full-screen overlay (close revokes blob URL)
function showPdfInOverlay(url, filename) {
    try {
        if (!url) return;
        // remove existing overlay if present
        const prev = document.getElementById('pdf-fullscreen-overlay');
        if (prev && prev.parentNode) prev.parentNode.removeChild(prev);

        const ov = document.createElement('div');
        ov.id = 'pdf-fullscreen-overlay';
        ov.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:2147483647; display:flex; align-items:center; justify-content:center;';

        const container = document.createElement('div');
        container.style.cssText = 'position:relative; width:100%; height:100%;';

        const iframe = document.createElement('iframe');
        iframe.id = 'pdf-viewer-iframe';
        // load the lightweight viewer which accepts pdf bytes via postMessage
        iframe.src = './assets/pdf-viewer.html';
        iframe.style.cssText = 'width:100%; height:100%; border:none; background:#fff;';

        const close = document.createElement('button');
        close.textContent = 'Kapat';
        close.style.cssText = 'position:absolute; right:14px; top:14px; z-index:2147483648; background:#111; color:#fff; border:none; padding:10px 12px; border-radius:8px; cursor:pointer; font-weight:700';
        let cleanup = function(){
            try {
                // ask iframe to terminate and wait briefly for confirmation so it can restore touch/overscroll state
                let responded = false;
                function onTerminated(ev) {
                    try {
                        const m = ev.data || {};
                        if (m && m.type === 'viewer-terminated') {
                            responded = true;
                            try { window.removeEventListener('message', onTerminated); } catch(e){}
                            finalize();
                        }
                    } catch(e){}
                }
                function finalize(){
                    try { if (iframe) { iframe.src = 'about:blank'; } } catch(e){}
                    try { if (ov && ov.parentNode) ov.parentNode.removeChild(ov); } catch(e){}
                    try { if (_lastReceiptBlobUrl) { URL.revokeObjectURL(_lastReceiptBlobUrl); } } catch(e){}
                    _lastReceiptBlobUrl = null;
                    try { window.removeEventListener('message', onMessage); } catch(e){}
                    // Additional aggressive restores to help Chrome Android re-enable scrolling
                    try { if (document.activeElement && typeof document.activeElement.blur === 'function') document.activeElement.blur(); } catch(e){}
                    try { document.body.style.pointerEvents = ''; } catch(e){}
                    try { document.documentElement.style.pointerEvents = ''; } catch(e){}
                    try { document.body.style.touchAction = ''; } catch(e){}
                    try { document.documentElement.style.touchAction = ''; } catch(e){}
                    try { document.body.style.overscrollBehavior = ''; } catch(e){}
                    try { document.documentElement.style.overscrollBehavior = ''; } catch(e){}
                    try { document.body.style.webkitOverflowScrolling = 'touch'; } catch(e){}
                    // clear inline touch/overscroll styles on elements (bounded loop for safety)
                    try {
                        const els = document.querySelectorAll('[style]');
                        for (let i = 0; i < els.length && i < 500; i++) {
                            try {
                                const s = els[i].style;
                                if (!s) continue;
                                if (s.touchAction === 'none') s.touchAction = '';
                                if (s.overscrollBehavior === 'none') s.overscrollBehavior = '';
                                if (s.webkitOverflowScrolling === 'auto') s.webkitOverflowScrolling = 'touch';
                            } catch(e){}
                        }
                    } catch(e){}
                    // restore body position and scroll if we saved them when opening the overlay
                    try {
                        if (ov && ov.dataset) {
                            const ss = ov.dataset._savedScroll ? parseInt(ov.dataset._savedScroll, 10) : NaN;
                            if (!isNaN(ss)) {
                                try { document.body.style.position = ov.dataset._prevBodyPosition || ''; } catch(e){}
                                try { document.body.style.top = ov.dataset._prevBodyTop || ''; } catch(e){}
                                try { document.body.style.left = ov.dataset._prevBodyLeft || ''; } catch(e){}
                                try { document.body.style.width = ov.dataset._prevBodyWidth || ''; } catch(e){}
                                try { document.body.style.overflow = ov.dataset._prevBodyOverflow || ''; } catch(e){}
                                try { window.scrollTo(0, ss); } catch(e){}
                            }
                        }
                    } catch(e){}
                    // reflow / small scroll nudge
                    try { void document.body.offsetHeight; } catch(e){}
                    try { window.scrollTo(0, Math.max(0, window.scrollY - 1)); window.scrollTo(0, window.scrollY + 1); } catch(e){}
                }

                try { window.addEventListener('message', onTerminated, false); } catch(e){}
                try { if (iframe && iframe.contentWindow) iframe.contentWindow.postMessage({ type: 'overlay-terminate' }, '*'); } catch(e){}

                // fallback: if iframe does not respond within 300ms, finalize anyway
                setTimeout(function(){ if (!responded) { try { window.removeEventListener('message', onTerminated); } catch(e){} finalize(); } }, 300);
            } catch(e){
                try { if (iframe) { iframe.src = 'about:blank'; } } catch(e){}
                try { if (ov && ov.parentNode) ov.parentNode.removeChild(ov); } catch(e){}
                try { if (_lastReceiptBlobUrl) { URL.revokeObjectURL(_lastReceiptBlobUrl); } } catch(e){}
                _lastReceiptBlobUrl = null;
                try { window.removeEventListener('message', onMessage); } catch(e){}
            }
        };
        close.addEventListener('click', cleanup);


        // message handler to send pdf bytes when viewer is ready and handle close requests
        function onMessage(ev){
            try {
                const m = ev.data || {};
                if (!m) return;
                if (m.type === 'viewer-ready') {
                    // fetch blob URL as arrayBuffer and send as transferable
                    (async function(){
                        try {
                            const resp = await fetch(url);
                            if (!resp.ok) return;
                            const ab = await resp.arrayBuffer();
                            try {
                                iframe.contentWindow.postMessage({ type: 'pdf-bytes', buffer: ab }, '*', [ab]);
                            } catch (e2) {
                                // fallback without transfer
                                try { iframe.contentWindow.postMessage({ type: 'pdf-bytes', buffer: ab }, '*'); } catch(e3){}
                            }
                        } catch(e){}
                    })();
                } else if (m.type === 'close-request') {
                    cleanup();
                }
            } catch (e) {}
        }

        window.addEventListener('message', onMessage, false);

        // prevent background scrolling while overlay open
        let _prevBodyOverflow = document.body.style.overflow;
        let _prevHtmlOverscroll = document.documentElement.style.overscrollBehavior;
        let _prevHtmlTouchAction = document.documentElement.style.touchAction;
        // Use position:fixed freeze which is more reliable on mobile browsers
        try {
            const scrollY = window.scrollY || window.pageYOffset || 0;
            // save previous body styles on overlay element
            ov.dataset._savedScroll = String(scrollY || 0);
            ov.dataset._prevBodyPosition = document.body.style.position || '';
            ov.dataset._prevBodyTop = document.body.style.top || '';
            ov.dataset._prevBodyLeft = document.body.style.left || '';
            ov.dataset._prevBodyWidth = document.body.style.width || '';
            ov.dataset._prevBodyOverflow = _prevBodyOverflow || '';

            document.body.style.position = 'fixed';
            document.body.style.top = '-' + (scrollY || 0) + 'px';
            document.body.style.left = '0';
            document.body.style.width = '100%';
            document.body.style.overflow = 'hidden';

            // also set html overscroll/touch-action to avoid scroll chaining on mobile
            document.documentElement.style.overscrollBehavior = 'none';
            document.documentElement.style.touchAction = 'none';
        } catch(e){}

        container.appendChild(iframe);
        container.appendChild(close);
        ov.appendChild(container);
        document.body.appendChild(ov);

        // ensure cleanup restores scrolling and touch-related styles
        const originalCleanup = cleanup;
        cleanup = function(){
            try { document.body.style.overflow = _prevBodyOverflow || ''; } catch(e){}
            try { document.documentElement.style.overscrollBehavior = _prevHtmlOverscroll || ''; } catch(e){}
            try { document.documentElement.style.touchAction = _prevHtmlTouchAction || ''; } catch(e){}
            // small reflow/scroll nudge to help mobile browsers re-evaluate scrollability
            try { window.scrollTo(0, Math.max(0, window.scrollY - 1)); window.scrollTo(0, window.scrollY + 1); } catch(e){}
            try { originalCleanup(); } catch(e){}
        };

        // Extra safety: ensure body touch/scroll smoothing properties preserved/restored
        try {
            const prevBodyTouch = document.body.style.touchAction;
            const prevBodyWebkit = document.body.style.webkitOverflowScrolling;
            // store them on overlay element so they survive closure scope
            ov.dataset._prevBodyTouch = prevBodyTouch || '';
            ov.dataset._prevBodyWebkit = prevBodyWebkit || '';
        } catch(e){}
    } catch (e) {}
}

// Intercept clicks on anchors that point to blob: or .pdf URLs and show overlay instead of opening a new tab
document.addEventListener('click', function(ev){
    try {
        const a = ev.target.closest && ev.target.closest('a');
        if (!a) return;
        const href = a.getAttribute && a.getAttribute('href');
        if (!href || typeof href !== 'string') return;

        // blob: URLs -> show overlay directly
        if (href.indexOf('blob:') === 0) {
            ev.preventDefault(); ev.stopPropagation();
            try { showPdfInOverlay(href, a.getAttribute('download') || 'yakit-fisi.pdf'); } catch(e){}
            return;
        }

        // If link targets a PDF file (local or absolute), fetch it and show overlay
        const isPdfLink = /\.pdf(?:\?|#|$)/i.test(href);
        if (isPdfLink) {
            ev.preventDefault(); ev.stopPropagation();
            (async function(){
                try {
                    // Resolve relative URLs against location
                    const resolved = new URL(href, window.location.href).toString();
                    const resp = await fetch(resolved);
                    if (!resp.ok) {
                        // cannot fetch the PDF; show a notice instead of opening a new tab
                        setNotice(["PDF indirilemedi veya bulunamadı."],'error');
                        return;
                    }
                    const blob = await resp.blob();
                    const url = URL.createObjectURL(blob);
                    // revoke previous blob if any
                    try { if (_lastReceiptBlobUrl) { URL.revokeObjectURL(_lastReceiptBlobUrl); } } catch(e){}
                    _lastReceiptBlobUrl = url;
                    const filename = a.getAttribute('download') || (resolved.split('/').pop() || 'form.pdf');
                    try { showPdfInOverlay(url, filename); } catch (e) {
                        setNotice(["PDF görüntülenemedi."],'error');
                    }
                } catch (e) {
                    setNotice(["PDF alınırken hata oluştu."],'error');
                }
            })();
        }
    } catch (e) {}
}, true);

>>>>>>> 007becc (chore: prepare release v7.3.48)
async function openPdfReceipt(log, debugForceMode) {
    await loadPdfLib();
    const pdfDebugMode = (function(){
        if (debugForceMode) return String(debugForceMode).trim().toLowerCase();
        try { return String(new URL(window.location.href).searchParams.get('pdf_debug') || '').trim().toLowerCase(); } catch (e) { return ''; }
    })();
    const pdfDebug = (pdfDebugMode === '1' || pdfDebugMode === 'true' || pdfDebugMode === 'grid');
    const url = './assets/fuel-slip-blank-u.pdf';
    const res = await fetch(url);
    if (!res.ok) throw new Error('PDF şablonu bulunamadı');
    const arrayBuffer = await res.arrayBuffer();
    const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
    const pages = pdfDoc.getPages();
    const page = pages[0];
    const { width, height } = page.getSize();
    const helv = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);

    // Debug helpers
    function drawCornerMarkers() {
        if (!pdfDebugMode) return;
        const f = helv;
        const c = PDFLib.rgb(1, 0, 0);
        const s = 9;
        page.drawText(`(0,0)`, { x: 4, y: 4, size: s, font: f, color: c });
        page.drawText(`(W,0)`, { x: Math.max(4, width - 46), y: 4, size: s, font: f, color: c });
        page.drawText(`(0,H)`, { x: 4, y: Math.max(4, height - 14), size: s, font: f, color: c });
        page.drawText(`(W,H)`, { x: Math.max(4, width - 46), y: Math.max(4, height - 14), size: s, font: f, color: c });
        page.drawText(`W=${Math.round(width)} H=${Math.round(height)}`, { x: 60, y: 4, size: s, font: f, color: c });
    }

    function drawGridOverlay() {
        if (pdfDebugMode !== 'grid') return;
        const step = 0.05; // 5% grid
        const lineColor = PDFLib.rgb(0.85, 0.2, 0.2);
        for (let t = 0; t <= 1.0001; t += step) {
            const x = Math.round(width * t);
            const y = Math.round(height * t);
            // vertical
            page.drawLine({ start: { x, y: 0 }, end: { x, y: height }, thickness: 0.5, color: lineColor });
            // horizontal
            page.drawLine({ start: { x: 0, y }, end: { x: width, y }, thickness: 0.5, color: lineColor });
            // labels
            const lbl = String(Math.round(t * 100)).padStart(2, '0');
            page.drawText(lbl, { x: Math.min(width - 18, x + 2), y: 6, size: 7, font: helv, color: lineColor });
            page.drawText(lbl, { x: 6, y: Math.min(height - 10, y + 2), size: 7, font: helv, color: lineColor });
        }
    }

    // Draw labeled boxes around configured tickRegions to aid visual tuning
    function drawRegionBoxes() {
        if (pdfDebugMode !== 'grid') return;
        try {
            const boxColor = PDFLib.rgb(0, 0.6, 0);
            const labelFont = embeddedFont || helv;
            Object.keys(tickRegions).forEach((key, idx) => {
                const r = tickRegions[key];
                if (!r) return;
                // approximate bounding box: left depends on whether region draws right-to-left or left-to-right
                const span = (r.spacing || 0.02) * (r.count || 1);
                const leftFrac = (r.xStart && r.xStart > 0.5 && key.includes('actual')) ? (r.xStart - span - 0.005) : Math.max(0, (r.xStart || 0) - 0.005);
                const rightFrac = Math.min(0.999, (r.xStart || 0) + 0.01 + span);
                const topFrac = Math.max(0, (r.y || 0) - 0.02);
                const bottomFrac = Math.min(0.999, (r.y || 0) + 0.02);
                const lx = Math.round(width * leftFrac);
                const rx = Math.round(width * rightFrac);
                const ty = Math.round(height * topFrac);
                const by = Math.round(height * bottomFrac);
                const wbox = Math.max(6, rx - lx);
                const hbox = Math.max(6, by - ty);
                page.drawRectangle({ x: lx, y: ty, width: wbox, height: hbox, borderColor: boxColor, borderWidth: 0.8 });
                // label
                const lbl = String(key + ' (' + (r.count || '') + ')');
                page.drawText(lbl, { x: lx + 2, y: Math.max(2, ty + hbox - 10), size: 8, font: labelFont, color: boxColor });
            });
        } catch (e) {
            // ignore debug overlay errors
        }
    }

    function normalizeWinAnsi(str) {
        if (!str) return '';
        const map = {
            '\u0130': 'I', // İ
            '\u0131': 'i', // ı
            'ç': 'c', 'Ç': 'C',
            'ğ': 'g', 'Ğ': 'G',
            'ş': 's', 'Ş': 'S',
            'ö': 'o', 'Ö': 'O',
            'ü': 'u', 'Ü': 'U'
        };
        return String(str).split('').map(ch => map[ch] || ch).join('');
    }

    // Optional: embed a Unicode-capable TTF from local assets if available.
    // We keep this local-only to avoid noisy network/CSP failures.
    let embeddedFont = helv;
    try {
        // Prefer a handwritten-style font for more realistic look (try IndieFlower CDN),
        // then fall back to local DejaVuSans.ttf, then to standard Helvetica.
        try {
            const url = 'https://github.com/google/fonts/raw/main/ofl/indieflower/IndieFlower.ttf';
            const rfont = await fetch(url);
            if (rfont && rfont.ok) {
                const fb = await rfont.arrayBuffer();
                embeddedFont = await pdfDoc.embedFont(fb);
            }
        } catch (e) {
            try {
                const fResp = await fetch('./assets/DejaVuSans.ttf');
                if (fResp && fResp.ok) {
                    const fb = await fResp.arrayBuffer();
                    embeddedFont = await pdfDoc.embedFont(fb);
                }
            } catch (e) {
                // final fallback to helv (already set)
            }
        }
    } catch (e) {
        // silent fallback to WinAnsi
    }

    // Unified write color (navy)
    const WRITE_COLOR = PDFLib.rgb(0.06, 0.22, 0.4);

    // Tick/box regions (use finalized mapping)
    const tickRegions = FINAL_TICK_REGIONS;

    // Debug overlays (drawn on top of the blank template)
    try { drawGridOverlay(); } catch (e) {}
    try { drawCornerMarkers(); } catch (e) {}
    try { drawRegionBoxes(); } catch (e) {}

    // Draw digits into vertical tick columns (right-aligned)
    function drawDigitsInTicks(val, xStartFrac, yFrac, spacingFrac, count, size, font) {
        const s = String(val ?? '').replace(/[^0-9\-]/g, '');
        const digits = s.split('');
        const usedFont = font || embeddedFont || helv;
        const fs = Number(size) || 12;
        for (let i = 0; i < count; i++) {
            const di = digits.length - 1 - i; // right aligned
            const ch = di >= 0 ? digits[di] : '';
            const x = Math.round(width * (xStartFrac - i * spacingFrac));
            const y = Math.round(height * yFrac);
            if (ch) {
                const dx = -Math.round(fs * 0.15);
                page.drawText(ch, { x: x + dx, y: y, size: fs, font: usedFont, color: WRITE_COLOR });
            }
            try { if (new URL(window.location.href).searchParams.get('pdf_debug') === '1') { page.drawText('.', { x: x-1, y: y-2, size: 6, font: usedFont, color: PDFLib.rgb(0,0,1) }); } } catch(e){}
        }
    }

    function digitsOnly(val) {
        return String(val ?? '').replace(/[^0-9\-]/g, '');
    }

    function toIntSafe(val) {
        const n = Number(String(val ?? '').replace(/[^0-9\-]/g, ''));
        return Number.isFinite(n) ? Math.trunc(n) : 0;
    }

    // Draw characters into horizontal boxes (left-to-right), one char per box
    function drawCharsInBoxes(str, xStartFrac, yFrac, spacingFrac, count, size, font) {
        const s = String(str ?? '');
        const usedFont = font || embeddedFont || helv;
        const fs = Number(size) || 12;
        for (let i = 0; i < count; i++) {
            const ch = s[i] || '';
            const x = Math.round(width * (xStartFrac + i * spacingFrac));
            const y = Math.round(height * yFrac);
            if (ch) {
                page.drawText(ch, { x: x, y: y, size: fs, font: usedFont, color: WRITE_COLOR });
            }
            try { if (new URL(window.location.href).searchParams.get('pdf_debug') === '1') { page.drawText('|', { x: x-2, y: y-2, size: 6, font: usedFont, color: PDFLib.rgb(0,0,0) }); } } catch(e){}
        }
    }

    // Render temperature in °C into three small boxes as sign+2digits (e.g. +25, -05)
    (function(){
        const raw = String(log.tempC ?? '').trim();
        let tnum = null;
        if (raw !== '') {
            const parsed = Number(raw);
            if (!Number.isNaN(parsed)) tnum = Math.round(parsed);
        }
        const tempStr = (tnum === null) ? '   ' : ((tnum >= 0 ? '+' : '-') + String(Math.abs(tnum)).padStart(2,'0'));
        try {
            drawCharsInBoxes(tempStr, tickRegions.fuel_temp.xStart, tickRegions.fuel_temp.y, tickRegions.fuel_temp.spacing, tickRegions.fuel_temp.count, tickRegions.fuel_temp.size, embeddedFont);
        } catch (e) {
            // no fallback drawText (avoid writing into header/red zones)
        }
    })();

    // ACTUAL SUPPLY (LT) in bottom-right table ticks
    try {
        let ltVal = '';
        if (log.lt !== undefined && log.lt !== null && String(log.lt).trim() !== '') {
            const n = Number(String(log.lt).replace(/[^0-9\.-]/g,''));
            if (!Number.isNaN(n)) ltVal = String(Math.round(n));
        }
        if (ltVal) drawDigitsInTicks(ltVal, tickRegions.actual_supply_lt.xStart, tickRegions.actual_supply_lt.y, tickRegions.actual_supply_lt.spacing, tickRegions.actual_supply_lt.count, tickRegions.actual_supply_lt.size, embeddedFont);
    } catch (e) {}

    // Compute main values
    const remainingKg = toIntSafe(log.act_total);
    const upliftKg = toIntSafe(log.kg);
    const blockKg = toIntSafe(log.block);
    const tgtTotalKg = Math.max(0, toIntSafe(log.tgt_l) + toIntSafe(log.tgt_c) + toIntSafe(log.tgt_r));

    // density small boxes (bottom section) — show three digits after decimal (e.g. 0.789 -> 789)
    try {
        const raw = String(log.dens ?? '').trim();
        let densDigits = '';
        const n = Number(raw);
        if (!Number.isNaN(n)) {
            const frac = Math.abs(n - Math.floor(n));
            const three = String(Math.round(frac * 1000)).padStart(3,'0');
            densDigits = three;
        }
        if (densDigits) {
            // Density is displayed in 3 horizontal boxes
            drawCharsInBoxes(densDigits, tickRegions.density_boxes.xStart, tickRegions.density_boxes.y, tickRegions.density_boxes.spacing, tickRegions.density_boxes.count, tickRegions.density_boxes.size, embeddedFont);
        }
    } catch (e) {}

    // Remaining (before fueling) in bottom-left long field
    try {
        if (remainingKg > 0) {
            drawDigitsInTicks(digitsOnly(remainingKg), tickRegions.remaining_left.xStart, tickRegions.remaining_left.y, tickRegions.remaining_left.spacing, tickRegions.remaining_left.count, tickRegions.remaining_left.size, embeddedFont);
        }
    } catch (e) {}

    // Actual supply fuel in bottom middle long field (use uplift KG)
    try {
        if (upliftKg > 0) {
            drawDigitsInTicks(digitsOnly(upliftKg), tickRegions.actual_supply_long.xStart, tickRegions.actual_supply_long.y, tickRegions.actual_supply_long.spacing, tickRegions.actual_supply_long.count, tickRegions.actual_supply_long.size, embeddedFont);
        }
    } catch (e) {}

    // Actual indicated block fuel in bottom right long field (use target total)
    try {
        if (tgtTotalKg > 0) {
            drawDigitsInTicks(digitsOnly(tgtTotalKg), tickRegions.actual_indic_block_long.xStart, tickRegions.actual_indic_block_long.y, tickRegions.actual_indic_block_long.spacing, tickRegions.actual_indic_block_long.count, tickRegions.actual_indic_block_long.size, embeddedFont);
        }
    } catch (e) {}

    // Registration (TC-ABC) in 6 boxes
    try {
        const reg = normalizeReg(log.reg || '') || getRegistration();
        if (reg) {
            drawCharsInBoxes(reg, tickRegions.registration_boxes.xStart, tickRegions.registration_boxes.y, tickRegions.registration_boxes.spacing, tickRegions.registration_boxes.count, tickRegions.registration_boxes.size, embeddedFont);
        }
    } catch (e) {}

    // Mid-table Requested / Actual columns (BLOCK / REMAINING / SUPPLY)
    try {
        // Requested
        if (blockKg > 0) drawDigitsInTicks(digitsOnly(blockKg), tickRegions.requested_block.xStart, tickRegions.requested_block.y, tickRegions.requested_block.spacing, tickRegions.requested_block.count, tickRegions.requested_block.size, embeddedFont);
        if (remainingKg > 0) drawDigitsInTicks(digitsOnly(remainingKg), tickRegions.requested_remain.xStart, tickRegions.requested_remain.y, tickRegions.requested_remain.spacing, tickRegions.requested_remain.count, tickRegions.requested_remain.size, embeddedFont);
        if (upliftKg > 0) drawDigitsInTicks(digitsOnly(upliftKg), tickRegions.requested_supply.xStart, tickRegions.requested_supply.y, tickRegions.requested_supply.spacing, tickRegions.requested_supply.count, tickRegions.requested_supply.size, embeddedFont);

        // Actual indicated
        if (tgtTotalKg > 0) drawDigitsInTicks(digitsOnly(tgtTotalKg), tickRegions.actual_block.xStart, tickRegions.actual_block.y, tickRegions.actual_block.spacing, tickRegions.actual_block.count, tickRegions.actual_block.size, embeddedFont);
        if (remainingKg > 0) drawDigitsInTicks(digitsOnly(remainingKg), tickRegions.actual_remain.xStart, tickRegions.actual_remain.y, tickRegions.actual_remain.spacing, tickRegions.actual_remain.count, tickRegions.actual_remain.size, embeddedFont);
        if (upliftKg > 0) drawDigitsInTicks(digitsOnly(upliftKg), tickRegions.actual_supply.xStart, tickRegions.actual_supply.y, tickRegions.actual_supply.spacing, tickRegions.actual_supply.count, tickRegions.actual_supply.size, embeddedFont);
    } catch (e) {}
    // If debug enabled via URL param ?pdf_debug=1 show markers for target regions only
    try {
        if (pdfDebug) {
            const markerFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
            const mark = (name, xFrac, yFrac) => {
                const x = Math.round(width * xFrac);
                const y = Math.round(height * yFrac);
                page.drawText('•', { x: x - 3, y: y - 3, size: 12, font: markerFont, color: PDFLib.rgb(1,0,0) });
                page.drawText(name, { x: x + 6, y: y - 3, size: 8, font: markerFont, color: PDFLib.rgb(1,0,0) });
            };
            mark('actual_supply_lt', tickRegions.actual_supply_lt.xStart, tickRegions.actual_supply_lt.y);
            mark('density_boxes', tickRegions.density_boxes.xStart, tickRegions.density_boxes.y);
            mark('remaining_left', tickRegions.remaining_left.xStart, tickRegions.remaining_left.y);
            mark('actual_supply_long', tickRegions.actual_supply_long.xStart, tickRegions.actual_supply_long.y);
            mark('actual_indic_block_long', tickRegions.actual_indic_block_long.xStart, tickRegions.actual_indic_block_long.y);
            mark('registration_boxes', tickRegions.registration_boxes.xStart, tickRegions.registration_boxes.y);
            mark('fuel_temp', tickRegions.fuel_temp.xStart, tickRegions.fuel_temp.y);
            mark('requested_block', tickRegions.requested_block.xStart, tickRegions.requested_block.y);
            mark('requested_remain', tickRegions.requested_remain.xStart, tickRegions.requested_remain.y);
            mark('requested_supply', tickRegions.requested_supply.xStart, tickRegions.requested_supply.y);
            mark('actual_block', tickRegions.actual_block.xStart, tickRegions.actual_block.y);
            mark('actual_remain', tickRegions.actual_remain.xStart, tickRegions.actual_remain.y);
            mark('actual_supply', tickRegions.actual_supply.xStart, tickRegions.actual_supply.y);
        }
    } catch (e) {}

    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    if (_lastReceiptBlobUrl) { try { URL.revokeObjectURL(_lastReceiptBlobUrl); } catch(e){} }
    _lastReceiptBlobUrl = URL.createObjectURL(blob);
    const iframe = document.getElementById('receipt-iframe');
    const details = document.getElementById('r-details');

    // Try inline render with PDF.js first; if it fails, fall back to Open/Download button.
<<<<<<< HEAD
    let didRender = false;
    try {
        didRender = await renderPdfWithPdfJs(pdfBytes);
    } catch (e) { didRender = false; }
=======
    // Inline rendering disabled — always use overlay to display generated PDF
    let didRender = false;
>>>>>>> 007becc (chore: prepare release v7.3.48)

    if (!didRender) {
        try {
            let openBtn = document.getElementById('receipt-open-btn');
            const createBtn = () => {
                const b = document.createElement('button');
                b.id = 'receipt-open-btn';
                b.type = 'button';
                b.textContent = 'Aç / İndir PDF';
                b.style.cssText = 'width:100%; background:#5b9bff; color:#fff; border:none; padding:12px; margin-top:12px; font-weight:800; border-radius:6px; cursor:pointer';
                b.addEventListener('click', function(){
<<<<<<< HEAD
                    try { window.open(_lastReceiptBlobUrl, '_blank'); }
                    catch (e) {
                        const a = document.createElement('a');
                        a.href = _lastReceiptBlobUrl;
                        a.download = 'yakit-fisi.pdf';
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
=======
                    try {
                        showPdfInOverlay(_lastReceiptBlobUrl, 'yakit-fisi.pdf');
                    } catch (e) {
                        try {
                            const a = document.createElement('a');
                            a.href = _lastReceiptBlobUrl;
                            a.download = 'yakit-fisi.pdf';
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                        } catch (e2) {}
>>>>>>> 007becc (chore: prepare release v7.3.48)
                    }
                });
                return b;
            };

            if (!openBtn) {
                openBtn = createBtn();
                const rc = document.querySelector('#receipt-modal .receipt-content');
                if (rc) {
                    const closeBtn = rc.querySelector('#receipt-close');
                    if (closeBtn) rc.insertBefore(openBtn, closeBtn);
                    else rc.appendChild(openBtn);
                }
            } else {
                // Re-create handler to ensure it uses the latest blob URL
                openBtn.parentNode && openBtn.parentNode.removeChild(openBtn);
                const rc = document.querySelector('#receipt-modal .receipt-content');
                if (rc) {
                    openBtn = createBtn();
                    const closeBtn = rc.querySelector('#receipt-close');
                    if (closeBtn) rc.insertBefore(openBtn, closeBtn);
                    else rc.appendChild(openBtn);
                }
            }
            // Add a lightweight developer button to force-unregister Service Worker and clear caches
            try {
                const isLanHost = /^(localhost|127\.|192\.168\.|10\.|172\.)/.test(location.hostname);
                if (isLanHost) {
                    let resetBtn = document.getElementById('receipt-reset-sw');
                    const createReset = () => {
                        const b = document.createElement('button');
                        b.id = 'receipt-reset-sw';
                        b.type = 'button';
                        b.textContent = 'SW Yenile (dev)';
                        b.style.cssText = 'width:100%; background:#666; color:#fff; border:none; padding:8px; margin-top:8px; font-weight:700; border-radius:6px; cursor:pointer; font-size:12px';
                        b.addEventListener('click', async function(){
                            try {
                                if ('serviceWorker' in navigator) {
                                    const regs = await navigator.serviceWorker.getRegistrations();
                                    for (const r of regs) { try { await r.unregister(); } catch(e){} }
                                }
                                if (typeof caches !== 'undefined' && caches && typeof caches.keys === 'function') {
                                    try {
                                        const keys = await caches.keys();
                                        for (const k of keys) { try { await caches.delete(k); } catch(e){} }
                                    } catch (e) {}
                                } else {
                                    // caches API not available in this context — nothing else we can do here
                                }
                            } catch (e) {}
                            location.reload(true);
                        });
                        return b;
                    };
                    if (!resetBtn) {
                        resetBtn = createReset();
                        const rc2 = document.querySelector('#receipt-modal .receipt-content');
                        if (rc2) {
                            const closeBtn2 = rc2.querySelector('#receipt-close');
                            if (closeBtn2) rc2.insertBefore(resetBtn, closeBtn2);
                            else rc2.appendChild(resetBtn);
                        }
                    }
                }
            } catch (e) {}
        } catch (e) {
            // non-fatal: nothing to do
        }
    } else {
        // If rendered inline, remove any old open button
        try { const ob = document.getElementById('receipt-open-btn'); if (ob && ob.parentNode) ob.parentNode.removeChild(ob); } catch(e){}
    }

    // Hide embedded iframe by default (mobile-friendly). Desktop users can still open via the button.
    if (iframe) { iframe.style.display = 'none'; iframe.src = ''; }
    if (details) details.style.display = 'none';
    const receiptModalEl = document.getElementById('receipt-modal');
    if (receiptModalEl) { receiptModalEl.style.display = 'flex'; receiptModalEl.style.pointerEvents = 'auto'; }
    // ensure close button also hides any rendered pdf-viewer overlay
    try {
        const closeBtn = document.getElementById('receipt-close');
        if (closeBtn && !closeBtn._sw_close_hooked) {
            closeBtn.addEventListener('click', function(){
                try {
                    const v = document.getElementById('pdf-viewer');
                    if (v) { v.style.display = 'none'; if (v.parentNode === document.body) document.body.removeChild(v); }
                    if (_lastReceiptBlobUrl) { try { URL.revokeObjectURL(_lastReceiptBlobUrl); } catch(e){} _lastReceiptBlobUrl = null; }
                } catch (e) {}
            });
            closeBtn._sw_close_hooked = true;
        }
    } catch (e) {}
    return true;
}

// Debug tools removed: nudger and live tick-region tweaking cleared for a clean build.

function openReceipt(log) {
    lastReceiptLog = log;
    // Use the legacy HTML receipt view instead of PDF output
    const date = escapeHtml(log.date);
    const time = escapeHtml(log.time);
    const fleetText = escapeHtml(log.fleet);
    const dens = escapeHtml(log.dens || '---');
    const tempC = escapeHtml(log.tempC || '---');
    const block = escapeHtml(log.block);
    const actTotal = escapeHtml(log.act_total);
    const actL = escapeHtml(log.act_l);
    const actC = escapeHtml(log.act_c);
    const actR = escapeHtml(log.act_r);
    const tgtL = escapeHtml(log.tgt_l);
    const tgtC = escapeHtml(log.tgt_c);
    const tgtR = escapeHtml(log.tgt_r);
    const kg = escapeHtml(log.kg);
    const lt = escapeHtml(log.lt);

    const iframe = document.getElementById('receipt-iframe');
    if (iframe) { iframe.style.display = 'none'; iframe.src = ''; }
    const detailsEl = document.getElementById('r-details');
    if (detailsEl) {
        detailsEl.style.display = 'block';
        detailsEl.innerHTML = `<b>${escapeHtml(t('label_date'))}:</b> ${date} ${time}<br><b>${escapeHtml(t('label_fleet'))}:</b> ${fleetText}<br><b>${escapeHtml(t('label_density'))}:</b> ${dens} | <b>${escapeHtml(t('label_temp'))}:</b> ${tempC}°C<br><hr style="border:0; border-top:1px dashed #000; margin:10px 0"><b>${escapeHtml(t('label_block'))}:</b> ${block} KG<br><b>${escapeHtml(t('label_actual'))}:</b> ${actTotal} KG<br><small>(LH:${actL} | CTR:${actC} | RH:${actR})</small><br><hr style="border:0; border-top:1px dashed #000; margin:10px 0"><b>${escapeHtml(t('label_target'))}:</b><br>LH: ${tgtL} | CTR: ${tgtC} | RH: ${tgtR} KG<br><hr style="border:0; border-top:2px solid #000; margin:10px 0"><div style="font-size:16px; font-weight:900">${escapeHtml(t('label_uplift_kg'))}: ${kg}<br>${escapeHtml(t('label_uplift_ltr'))}: ${lt}</div>`;
    }
    const receiptModalEl = document.getElementById('receipt-modal');
    if (receiptModalEl) { receiptModalEl.style.display = 'flex'; receiptModalEl.style.pointerEvents = 'auto'; }
}
// Service worker kaydı (offline desteği için)
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
            .then(reg => {
                try {
                    if (navigator.onLine) {
                        try { reg.update(); } catch (e) {}
                        try {
                            if (reg.waiting) {
                                try { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); } catch (e) {}
                            }
                            if (reg.installing) {
                                reg.installing.addEventListener('statechange', () => {
                                    try {
                                        if (reg.installing.state === 'installed' && reg.waiting && navigator.onLine) {
                                            try { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); } catch (e) {}
                                        }
                                    } catch (e) {}
                                });
                            }
                            reg.addEventListener('updatefound', () => {
                                try {
                                    const nw = reg.installing;
                                    if (nw) {
                                        nw.addEventListener('statechange', () => {
                                            try {
                                                if (nw.state === 'installed' && reg.waiting && navigator.onLine) {
                                                    try { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); } catch (e) {}
                                                }
                                            } catch (e) {}
                                        });
                                    }
                                } catch (e) {}
                            });
                        } catch (e) {}
                    }
                } catch (e) {}
            })
            .catch(() => {});

        try {
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                try {
                    if (!window.__swReloading) {
                        window.__swReloading = true;
                        window.location.reload();
                    }
                } catch (e) {}
            });
        } catch (e) {}
    });
}
window.addEventListener('load', () => {
    validateAll(false);
    setTimeout(updateAllUnits, 100);
    try {
        const r = document.getElementById('receipt-modal');
        if (r) { r.style.display = 'none'; r.style.pointerEvents = 'none'; }
        const w = document.getElementById('warning-modal');
        if (w) { w.style.display = 'none'; w.style.pointerEvents = 'none'; }
    } catch (e) {}
});

// Adjustable tick regions: defaults can be nudged via the debug UI and persisted to localStorage
// Finalized tick regions (fixed values determined from tuning)
const FINAL_TICK_REGIONS = {
    requested_block:   { xStart: 0.700, y: 0.502, spacing: 0.0185, count: 8, size: 12 },
    requested_remain:  { xStart: 0.700, y: 0.459, spacing: 0.0185, count: 8, size: 12 },
    requested_supply:  { xStart: 0.700, y: 0.419, spacing: 0.0185, count: 8, size: 12 },
    actual_block:      { xStart: 0.735, y: 0.479, spacing: 0.0185, count: 8, size: 12 },
    actual_remain:     { xStart: 0.745, y: 0.439, spacing: 0.0185, count: 8, size: 12 },
    actual_supply:     { xStart: 0.745, y: 0.399, spacing: 0.0185, count: 8, size: 12 },
    actual_supply_lt: { xStart: 0.942, y: 0.300, spacing: 0.020, count: 7, size: 11 },
    density_boxes: { xStart: 0.225, y: 0.144, spacing: 0.020, count: 3, size: 12 },
    remaining_left: { xStart: 0.188, y: 0.144, spacing: 0.020, count: 8, size: 12 },
    actual_supply_long: { xStart: 0.515, y: 0.144, spacing: 0.020, count: 8, size: 12 },
    actual_indic_block_long: { xStart: 0.770, y: 0.144, spacing: 0.020, count: 8, size: 12 },
    registration_boxes: { xStart: 0.435, y: 0.184, spacing: 0.022, count: 6, size: 12 },
    fuel_temp: { xStart: 0.710, y: 0.177, spacing: 0.035, count: 3, size: 12 }
};

// Re-create adjustable regions for runtime tweaking (nudger). Load overrides from localStorage if present.
// adjustableTickRegions removed: use FINAL_TICK_REGIONS only (clean build)

// Apply view mode once early
try { applyViewMode(); } catch (e) {}

// --- Cross-device return robustness (BFCache + delayed form restore) ---
const CALC_STATE_KEY = 'calc_state_v1';
let saveStateTimer = null;

function captureCalcState() {
    const ids = ['block_fuel','total_actual','la','ca','ra','density','temp_c','temp_f'];
    const out = { ts: Date.now(), data: {} };
    ids.forEach(id => {
        const el = document.getElementById(id);
        out.data[id] = el ? el.value : '';
    });
    return out;
}

function scheduleSaveCalcState() {
    try {
        if (saveStateTimer) clearTimeout(saveStateTimer);
        saveStateTimer = setTimeout(() => {
            try { sessionStorage.setItem(CALC_STATE_KEY, JSON.stringify(captureCalcState())); } catch (e) {}
        }, 120);
    } catch (e) {}
}

function shouldRestoreFromHistory(e) {
    if (e && e.persisted) return true;
    try {
        const nav = performance.getEntriesByType && performance.getEntriesByType('navigation');
        const entry = nav && nav[0];
        if (entry && entry.type === 'back_forward') return true;
        if (performance && performance.navigation && performance.navigation.type === 2) return true;
    } catch (err) {}
    return false;
}

function restoreCalcStateIfNeeded(e) {
    if (!shouldRestoreFromHistory(e)) return;
    let raw;
    try { raw = sessionStorage.getItem(CALC_STATE_KEY); } catch (err) { raw = null; }
    if (!raw) return;

    let state;
    try { state = JSON.parse(raw); } catch (err) { state = null; }
    if (!state || !state.data) return;

    // Sadece gerçekten boş kalan alanları restore et (RESET sonrası eski state'i geri basmasın).
    const ids = ['block_fuel','total_actual','la','ca','ra','density','temp_c','temp_f'];
    let didRestore = false;
    ids.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        const current = (el.value || '').trim();
        const saved = (state.data[id] ?? '').toString();
        if (current === '' && saved !== '') {
            el.value = saved;
            didRestore = true;
        }
    });

    if (didRestore) {
        // Unit pozisyonlarını da toparla
        setTimeout(updateAllUnits, 0);
    }
}

// Back/forward cache (özellikle iOS Safari/Chrome) dönüşlerinde `load` tetiklenmeyebilir.
// Ayrıca bazı cihazlarda input değerleri geri dönüşte gecikmeli restore edilir.
function refreshUIAfterReturn() {
    validateAll(false);
    updateAllUnits();

    requestAnimationFrame(() => {
        validateAll(false);
        updateAllUnits();
        requestAnimationFrame(() => {
            validateAll(false);
            updateAllUnits();
        });
    });

    setTimeout(() => {
        validateAll(false);
        updateAllUnits();
    }, 220);
}

window.addEventListener('pagehide', () => {
    try { sessionStorage.setItem(CALC_STATE_KEY, JSON.stringify(captureCalcState())); } catch (e) {}
});

window.addEventListener('pageshow', (e) => {
    restoreCalcStateIfNeeded(e);
    refreshUIAfterReturn();
});
window.addEventListener('focus', refreshUIAfterReturn);
document.addEventListener('visibilitychange', () => {
    if (!document.hidden) refreshUIAfterReturn();
});
window.addEventListener('resize', updateAllUnits);
</script>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script>
// Floating export button + PDF fill logic (uses assets/pdf_field_map.json)
(function(){
    function normalize(name){ return (name||'').toString().toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_]/g,''); }
    function asciiFold(s){ if(!s) return ''; return String(s).replace(/[İIıiÇçĞğŞşÖöÜü]/g, function(c){ return ({'İ':'I','I':'I','ı':'i','i':'i','Ç':'C','ç':'c','Ğ':'G','ğ':'g','Ş':'S','ş':'s','Ö':'O','ö':'o','Ü':'U','ü':'u'})[c]||c; }); }

    async function loadMap(){
        try{
            // Load the canonical mapping (single source of truth)
            let data = null;
            try{
                const r2 = await fetch('assets/pdf_calc_mapping.json');
                if(r2.ok) data = await r2.json();
            }catch(e){ data = null; }
            if(!data) return {};
            // If file uses new 'mappings' structure (objects with mappedTo/maxLen), normalize to legacy shape
            try {
                if (data && data.mappings && !data.fields) {
                    const fieldsObj = {};
                    const maxLenObj = {};
                    const fixedObj = data.fixed || {};
                    const pad6Arr = data.pad6 || [];
                    const noFillArr = data.noFill || [];
                    for (const k of Object.keys(data.mappings)) {
                        const v = data.mappings[k];
                        if (v && typeof v === 'object') {
                            fieldsObj[k] = v.mappedTo || '';
                            if (v.maxLen !== undefined) maxLenObj[k] = v.maxLen;
                        } else {
                            fieldsObj[k] = v;
                        }
                    }
                    data.fields = fieldsObj;
                    data.maxLen = Object.assign({}, data.maxLen || {}, maxLenObj);
                    data.fixed = Object.assign({}, data.fixed || {}, fixedObj);
                    data.pad6 = Array.isArray(data.pad6) && data.pad6.length ? data.pad6 : pad6Arr;
                    data.noFill = Array.isArray(data.noFill) && data.noFill.length ? data.noFill : noFillArr;
                }
            } catch (e) {}

            // build normalized lookup tables for resilient matching
            const lookup = {};
            const fixedLookup = {};
            const maxLenLookup = {};
            const pad6Set = new Set();

            function addLookup(k, v){
                if(k === undefined || k === null) return;
                const ks = String(k);
                lookup[ks] = v;
                lookup[ks.toLowerCase()] = v;
                lookup[ks.toUpperCase()] = v;
                lookup[normalize(ks)] = v;
                // ascii-folded variants (Turkish chars -> ASCII)
                const af = asciiFold(ks);
                lookup[af] = v;
                lookup[af.toLowerCase()] = v;
                lookup[normalize(af)] = v;
            }

            if(data && data.fields){
                for(const k of Object.keys(data.fields)) addLookup(k, data.fields[k]);
            }
            if(data && data.fixed){
                for(const k of Object.keys(data.fixed)){
                    const v = data.fixed[k];
                    const ks = String(k);
                    fixedLookup[ks] = v;
                    fixedLookup[ks.toLowerCase()] = v;
                    fixedLookup[ks.toUpperCase()] = v;
                    fixedLookup[normalize(ks)] = v;
                    // ascii-folded variants (Turkish chars -> ASCII) to improve matching
                    try{
                        const af = asciiFold(ks);
                        fixedLookup[af] = v;
                        fixedLookup[af.toLowerCase()] = v;
                        fixedLookup[normalize(af)] = v;
                    }catch(e){}
                }
            }
            if(data && data.maxLen){
                for(const k of Object.keys(data.maxLen)){
                    const v = data.maxLen[k];
                    maxLenLookup[k] = v;
                    maxLenLookup[String(k).toLowerCase()] = v;
                    maxLenLookup[String(k).toUpperCase()] = v;
                    maxLenLookup[normalize(String(k))] = v;
                }
            }
            if(data && Array.isArray(data.pad6)){
                for(const p of data.pad6){
                    const ps = String(p);
                    pad6Set.add(ps);
                    pad6Set.add(ps.toLowerCase());
                    pad6Set.add(ps.toUpperCase());
                    pad6Set.add(normalize(ps));
                    const af = asciiFold(ps);
                    pad6Set.add(af);
                    pad6Set.add(af.toLowerCase());
                    pad6Set.add(normalize(af));
                }
            }
            // optional: fields to skip entirely (do not set any value)
            const noFillSet = new Set();
            if(data && Array.isArray(data.noFill)){
                for(const p of data.noFill){
                    const ps = String(p);
                    noFillSet.add(ps);
                    noFillSet.add(ps.toLowerCase());
                    noFillSet.add(ps.toUpperCase());
                    noFillSet.add(normalize(ps));
                    const af = asciiFold(ps);
                    noFillSet.add(af);
                    noFillSet.add(af.toLowerCase());
                    noFillSet.add(normalize(af));
                }
            }

            data._lookup = lookup;
            data._fixedLookup = fixedLookup;
            data._maxLenLookup = maxLenLookup;
            data._pad6Set = pad6Set;
            data._noFillSet = noFillSet;

            return data;
        }catch(e){ return {}; }
    }

    function resolveSpecial(key){
        const d = new Date();
        if(key === '__registration') return (typeof getRegistration === 'function') ? getRegistration() : '';
        if(key === '__day') return String(d.getDate()).padStart(2,'0');
        if(key === '__month') return String(d.getMonth()+1).padStart(2,'0');
        if(key === '__now') return d.toLocaleDateString('tr-TR');
        if(key === '__time') return String(d.getHours()).padStart(2,'0') + ':' + String(d.getMinutes()).padStart(2,'0');
        return '';
    }

    async function resolveMappedValue(mapVal){
        if(!mapVal) return '';
        if(typeof mapVal === 'string' && mapVal.startsWith('__')){
            // special token handling
            // __registration: return registration (fallback to stored/local) processed
            if(mapVal === '__registration'){
                const special = resolveSpecial(mapVal);
                try{
                    const m = String(special || '').toUpperCase().match(/TC-(\w{3})/i);
                    if(m && m[1]) return m[1].toString();
                    const raw = String(special || '').replace(/[^A-Z0-9]/ig,'');
                    if(raw.length >= 3) return raw.slice(-3);
                    return raw;
                }catch(e){ return special; }
            }

            // __registration_from_url: only return registration if provided via URL param (cover page -> calc navigation)
            if(mapVal === '__registration_from_url'){
                const fromUrl = normalizeReg(REG_PARAM_RAW);
                if(!fromUrl) return '';
                // reuse resolveSpecial behavior for formatting
                const special = resolveSpecial('__registration');
                try{
                    const m = String(special || '').toUpperCase().match(/TC-(\w{3})/i);
                    if(m && m[1]) return m[1].toString();
                    const raw = String(special || '').replace(/[^A-Z0-9]/ig,'');
                    if(raw.length >= 3) return raw.slice(-3);
                    return raw;
                }catch(e){ return special; }
            }

            const special = resolveSpecial(mapVal);
            return special;
        }
        // try element by id or name
        let el = document.getElementById(mapVal) || document.querySelector('[name="'+mapVal+'"]');
        if(!el){
            // try normalized id
            el = document.getElementById(normalize(mapVal)) || document.querySelector('[name="'+normalize(mapVal)+'"]');
        }
        if(!el) return '';
        if(el.value !== undefined) return el.value;
        return el.textContent || el.innerText || '';
    }

    function makeFieldBackgroundTransparent(f){
        try{
            const acro = f && f.acroField;
            if(!acro) return;
            const widgets = acro.getWidgets ? acro.getWidgets() : (acro.dict && acro.dict.get ? acro.dict.get(PDFLib.PDFName.of('Kids')) : null);
            if(!widgets) return;
            for(const w of widgets){
                try{
                    // widget may be a dict-like object
                    if(w && typeof w.get === 'function'){
                        const mk = w.get(PDFLib.PDFName.of('MK')) || w.get('MK');
                        if(mk && typeof mk.delete === 'function'){
                            try{ mk.delete(PDFLib.PDFName.of('BG')); }catch(e){}
                        }
                        try{ w.delete && w.delete(PDFLib.PDFName.of('BG')); }catch(e){}
                        try{ w.dict && w.dict.delete && w.dict.delete(PDFLib.PDFName.of('BG')); }catch(e){}
                    } else if(w && w.dict && typeof w.dict.delete === 'function'){
                        try{ w.dict.delete(PDFLib.PDFName.of('BG')); }catch(e){}
                    }
                }catch(e){}
            }
        }catch(e){}
    }

    // More aggressive cleanup: remove appearance, background, border and default appearance keys
    function makeFieldBackgroundTransparentAggressive(f){
        try{
            const acro = f && f.acroField;
            if(!acro) return;
            const widgets = acro.getWidgets ? acro.getWidgets() : (acro.dict && acro.dict.get ? acro.dict.get(PDFLib.PDFName.of('Kids')) : null);
            if(!widgets) return;
            for(const w of widgets){
                try{
                    const dict = (w && w.dict) ? w.dict : w;
                    if(!dict) continue;
                    const toRemove = ['MK','BG','AP','DA','Border','BS'];
                    for(const k of toRemove){
                        try{ dict.delete(PDFLib.PDFName.of(k)); }catch(e){}
                    }
                    // Also try deleting plain string keys (lib internals may expose them that way)
                    for(const k of toRemove){
                        try{ dict.delete && dict.delete(k); }catch(e){}
                    }
                    // If there is an appearance dictionary, try to clear its Normal entry
                    try{
                        const ap = dict.get && dict.get(PDFLib.PDFName.of('AP'));
                        if(ap && ap.get && typeof ap.get === 'function'){
                            try{ ap.delete(PDFLib.PDFName.of('N')); }catch(e){}
                            try{ ap.delete('N'); }catch(e){}
                        }
                    }catch(e){}
                }catch(e){}
            }
        }catch(e){}
    }

    // Torch removed: simplified — feature intentionally disabled for web-only builds

    const btn = document.createElement('button');
    btn.id = 'export-pdf-btn';
    btn.textContent = 'Formu Görüntüle';
    Object.assign(btn.style, {
        display: 'block', width: '100%', marginTop: '12px',
        background: '#10b981', color: '#fff', border: 'none', padding: '12px 14px', borderRadius: '12px', fontWeight: 800, cursor: 'pointer', boxShadow: '0 6px 20px rgba(16,185,129,0.18)'
    });
    const saveBtn = document.getElementById('save-main-btn');
    if (saveBtn && saveBtn.parentNode) {
        saveBtn.parentNode.insertBefore(btn, saveBtn.nextSibling);
    } else {
        document.body.appendChild(btn);
    }

    // Fener butonu kaldırıldı — artık modal içinde veya sayfa düzeyinde kullanılmıyor

    // (PDF scan removed — mapping now comes from assets/pdf_calc_mapping.json)

    btn.addEventListener('click', async function(){
        btn.disabled = true; btn.textContent = 'Oluşturuluyor...';
        try{
            const map = await loadMap();
            // Load single PDF template (avoid unnecessary 404 requests)
            // Use the new blank template (u suffix) if available, otherwise fallback
            let templateUrl = 'assets/fuel-slip-blank-u.pdf';
            try{
                const chk = await fetch(templateUrl, { method: 'HEAD' });
                if(!chk.ok) templateUrl = 'assets/fuel-slip-blank.pdf';
            }catch(e){ templateUrl = 'assets/fuel-slip-blank.pdf'; }
            const res = await fetch(templateUrl);
            if(!res.ok) throw new Error('PDF yüklenemedi');
            const arrayBuffer = await res.arrayBuffer();
            const { PDFDocument } = PDFLib;
            const pdfDoc = await PDFDocument.load(arrayBuffer);
            const form = pdfDoc.getForm();
            const fields = form.getFields();

                // helper: attempt to draw a text directly into the widget rectangle using embeddedFont
                async function drawTextIntoWidget(f, text){
                    try{
                        const acro = f && f.acroField;
                        if(!acro) return false;
                        const widgets = acro.getWidgets ? acro.getWidgets() : (acro.dict && acro.dict.get ? acro.dict.get(PDFLib.PDFName.of('Kids')) : null);
                        if(!widgets || !widgets.length) return false;
                        const w = widgets[0];
                        let rect = null;
                        try{ rect = (typeof w.getRectangle === 'function') ? w.getRectangle() : (w.get && w.get('Rect')) || (w.dict && w.dict.get && w.dict.get(PDFLib.PDFName.of('Rect'))); }catch(e){}
                        if(!rect) return false;
                        const llx = Array.isArray(rect) ? rect[0] : rect.x1 || rect.left || null;
                        const lly = Array.isArray(rect) ? rect[1] : rect.y1 || rect.bottom || null;
                        const urx = Array.isArray(rect) ? rect[2] : rect.x2 || rect.right || null;
                        const ury = Array.isArray(rect) ? rect[3] : rect.y2 || rect.top || null;
                        if(llx === null || lly === null || urx === null || ury === null) return false;
                        const pgs = pdfDoc.getPages();
                        const page = pgs[0];
                        // Try to read default appearance (DA) to respect font/size/color defined in the PDF
                        let usedFont = null;
                        let fontSizeFromDA = null;
                        let colorFromDA = null;
                        try{
                            let da = null;
                            try{ da = (acro.getDefaultAppearance && typeof acro.getDefaultAppearance === 'function') ? acro.getDefaultAppearance() : null; }catch(e){}
                            if(!da && acro.dict && acro.dict.get){
                                try{ const daObj = acro.dict.get(PDFLib.PDFName.of('DA')); da = daObj ? String(daObj) : null; }catch(e){}
                            }
                            if(da){
                                const s = String(da);
                                const parts = s.trim().split(/\s+/);
                                // look for font token (starts with /) and size before Tf
                                for(let i=0;i<parts.length;i++){
                                    const t = parts[i];
                                    if(t === 'Tf' && i>=2){
                                        fontSizeFromDA = parseFloat(parts[i-1]) || null;
                                        const fn = parts[i-2] || null;
                                        if(fn && fn.indexOf('/') === 0){
                                            const fnn = fn.replace('/','');
                                            // map common resource names to pdf-lib StandardFonts
                                            const map = { 'Helv':'Helvetica', 'Helvetica':'Helvetica', 'TiRo':'TimesRoman', 'Times':'TimesRoman', 'Cour':'Courier', 'Courier':'Courier' };
                                            let std = null;
                                            for(const k of Object.keys(map)) if(fnn.indexOf(k) !== -1){ std = map[k]; break; }
                                            if(std === 'Helvetica') usedFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                                            else if(std === 'TimesRoman') usedFont = await pdfDoc.embedFont(PDFLib.StandardFonts.TimesRoman);
                                            else if(std === 'Courier') usedFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Courier);
                                        }
                                    }
                                    // detect rgb color tokens before 'rg'
                                    if(t === 'rg' && i>=3){
                                        const r = parseFloat(parts[i-3]) || 0;
                                        const g = parseFloat(parts[i-2]) || 0;
                                        const b = parseFloat(parts[i-1]) || 0;
                                        colorFromDA = PDFLib.rgb(r,g,b);
                                    }
                                }
                            }
                        }catch(e){}
                        if(!usedFont) usedFont = embeddedFont || await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                        const boxW = urx - llx;
                        const boxH = ury - lly;
                        // start with a reasonable font size, then shrink until the text fits within boxW (with small padding)
                        let fontSize = Math.min(boxH * 0.85, 18);
                        let textWidth = 0;
                        try{ textWidth = usedFont.widthOfTextAtSize ? usedFont.widthOfTextAtSize(String(text), fontSize) : (String(text).length * fontSize * 0.5); }catch(e){ textWidth = String(text).length * fontSize * 0.5; }
                        const maxW = Math.max(4, boxW - 4);
                        while(textWidth > maxW && fontSize > 4){
                            fontSize = Math.max(4, Math.floor(fontSize - 1));
                            try{ textWidth = usedFont.widthOfTextAtSize ? usedFont.widthOfTextAtSize(String(text), fontSize) : (String(text).length * fontSize * 0.5); }catch(e){ textWidth = String(text).length * fontSize * 0.5; }
                        }
                        // If still too wide, truncate the string to fit (avoid visual overflow)
                        let finalText = String(text);
                        try{
                            while(textWidth > maxW && finalText.length > 0){
                                finalText = finalText.slice(0, -1);
                                textWidth = usedFont.widthOfTextAtSize ? usedFont.widthOfTextAtSize(finalText, fontSize) : (finalText.length * fontSize * 0.5);
                            }
                        }catch(e){ /* ignore */ }
                        // Heuristic: if still not found, try substring/normalized matches between PDF field name and fixed keys
                        try{
                            if((fixedVal === null || fixedVal === undefined) && map && map._fixedLookup){
                                const lname = normalize(String(name || ''));
                                for(const fk of Object.keys(map._fixedLookup)){
                                    const nf = normalize(String(fk || ''));
                                    const afk = (typeof asciiFold === 'function') ? normalize(asciiFold(String(fk || ''))) : nf;
                                    if(nf === lname || afk === lname || lname.indexOf(nf) !== -1 || nf.indexOf(lname) !== -1){
                                        fixedVal = map._fixedLookup[fk];
                                        break;
                                    }
                                }
                            }
                        }catch(e){ /* ignore */ }
                        // center text horizontally and vertically
                        const drawX = llx + Math.max(2, (boxW - textWidth) / 2);
                        const drawY = lly + (boxH - fontSize) / 2;
                        const useColor = colorFromDA || WRITE_COLOR;
                        page.drawText(finalText, { x: drawX, y: drawY, size: fontSizeFromDA || fontSize, font: usedFont, color: useColor });
                        return true;
                    }catch(e){ return false; }
                }

            // Helper: robust fixed lookup for PDF field names (check many normalized variants)
            function getFixedForField(name, map){
                if(!map || !map._fixedLookup) return null;
                const candidates = [];
                try{
                    const s = String(name || '');
                    const n = normalize(s);
                    const af = (typeof asciiFold === 'function') ? asciiFold(s) : s;
                    const naf = (typeof asciiFold === 'function') ? normalize(asciiFold(s)) : normalize(s);
                    // raw forms
                    candidates.push(s);
                    candidates.push(s.toLowerCase());
                    candidates.push(s.toUpperCase());
                    // normalized with underscores
                    candidates.push(n);
                    // normalized without underscores (remove underscores/spaces)
                    candidates.push(n.replace(/_/g,''));
                    // space-removed/raw without spaces
                    candidates.push(s.replace(/\s+/g,''));
                    // ascii-folded variants
                    candidates.push(af);
                    candidates.push(af.toLowerCase());
                    candidates.push(af.toUpperCase());
                    candidates.push(naf);
                    candidates.push(naf.replace(/_/g,''));
                }catch(e){ }
                for(const c of candidates){
                    if(c === undefined || c === null) continue;
                    if(map._fixedLookup[c] !== undefined) return map._fixedLookup[c];
                }
                return null;
            }

            for(const f of fields){
                // dış kapsamda kullanılacak: temp alanı tespiti
                let isTempField = false;
                try{
                    const name = f.getName();
                    const mapped = (map && map._lookup) ? (map._lookup[name] || map._lookup[normalize(name)] || null) : (map[name] || map[normalize(name)] || map[name.toUpperCase()] || null);
                    let value = '';
                    const fixedVal = getFixedForField(f.getName && typeof f.getName === 'function' ? f.getName() : f.name, map) || (map && map.fixed ? (map.fixed[f.getName && typeof f.getName === 'function' ? f.getName() : f.name] || null) : null);
                    // If this field is configured to be skipped, do not set any value
                    try{
                        const noFillSet = (map && map._noFillSet) ? map._noFillSet : new Set();
                        if(noFillSet.has(name) || noFillSet.has(normalize(name)) || noFillSet.has(String(name).toUpperCase())){
                            continue;
                        }
                    }catch(e){}
                        if(fixedVal !== null && fixedVal !== undefined){
                        // If field has a fixed mapping (like 'u' or 'LT'), write it directly and skip further formatting
                        const fixedStr = String(fixedVal);
                        try{ form.getTextField(name).setText(fixedStr); makeFieldBackgroundTransparent(f); continue; }catch(e){}
                        try{ if(typeof f.setText === 'function') { f.setText(fixedStr); makeFieldBackgroundTransparent(f); continue; } }catch(e){}
                    } else if(mapped){
                        value = await resolveMappedValue(mapped);
                        // If this mapping points to the important total_actual field, prefer reading the
                        // page input directly to avoid any resolution edge-cases.
                        try{
                            if(String(mapped).toLowerCase() === 'total_actual'){
                                const el = document.getElementById('total_actual');
                                if(el) value = (el.value !== undefined) ? String(el.value) : (el.textContent || el.innerText || value);
                            }
                        }catch(e){ /* ignore */ }
                    } else {
                        // fallback: try element with same name/id
                        let el = document.getElementById(name) || document.querySelector('[name="'+name+'"]') || document.getElementById(normalize(name));
                        if(el) value = (el.value !== undefined) ? el.value : (el.textContent || '');
                    }

                    const pad6Set = (map && map._pad6Set) ? map._pad6Set : (map && Array.isArray(map.pad6) ? new Set(map.pad6) : new Set());
                    const needsPad6 = pad6Set.has(name) || pad6Set.has(normalize(name)) || pad6Set.has(String(name).toLowerCase()) || pad6Set.has(String(name).toUpperCase());

                    // Debug: log mapping resolution for this field
                    try{ console.debug('[pdf-fill] field=', name, 'mapped=', mapped, 'fixedVal=', fixedVal, 'valueRaw=', value, 'needsPad6=', needsPad6); }catch(e){}
                    // Extra debug for the important "ikmalden önce KALAN YAKIT kg" -> total_actual mapping
                    try{
                        if(String(name).toLowerCase().includes('ikmalden') && String(mapped).toLowerCase() === 'total_actual'){
                            console.info('[pdf-fill-debug] target field=', name, 'resolved total_actual=', value);
                        }
                    }catch(e){}

                    // Ensure every field is set; use '-' as fallback for empty values
                    let setVal = (value !== undefined && value !== null && String(value).toString().trim() !== '') ? String(value) : '-';

                    // Special formatting for SICAKLIK C: first char is sign (+/-), then two digits (pad with 0 if needed)
                    try {
                        // Apply temperature formatting when the target is our temp field or PDF field indicates temperature.
                        isTempField = (String(mapped || '').toLowerCase() === 'temp_c') ||
                                            (name && (String(name).toUpperCase() === 'SICAKLIK C' || String(name).toUpperCase() === 'TEMP C')) ||
                                            normalize(name) === normalize('SICAKLIK C') || normalize(name) === normalize('temp c') ||
                                            // also check if this PDF field maps (via nameToKey) to a mapping entry whose mappedTo is temp_c
                                            (map && map._nameToKey && (function(){
                                                try{
                                                    const orig = map._nameToKey[name] || map._nameToKey[normalize(name)] || map._nameToKey[String(name).toLowerCase()] || map._nameToKey[String(name).toUpperCase()] || null;
                                                    if(!orig) return false;
                                                    const entry = map.mappings && map.mappings[orig];
                                                    return entry && (String(entry.mappedTo || '').toLowerCase() === 'temp_c');
                                                }catch(e){ return false; }
                                            })());
                        if(isTempField){
                            const tempCEl = document.getElementById('temp_c');
                            let cVal = null;
                            try{
                                const cRaw = tempCEl ? (tempCEl.value !== undefined ? String(tempCEl.value).trim() : '') : '';
                                if(cRaw !== ''){
                                    const cnum = Number(cRaw.replace(',', '.'));
                                    if(!Number.isNaN(cnum)) cVal = Math.round(cnum);
                                }
                            }catch(e){}

                            if(cVal === null){
                                setVal = '+00';
                            } else {
                                const sign = (cVal < 0) ? '-' : '+';
                                let digits = String(Math.abs(Math.round(cVal)));
                                if (digits.length > 2) digits = digits.slice(-2);
                                if (digits.length === 1) digits = digits + ' ';
                                else if (digits.length === 0) digits = '  ';
                                setVal = sign + digits;
                            }
                        }
                    } catch (e) { /* ignore and continue */ }

                    const maxLenMap = (map && map._maxLenLookup) ? map._maxLenLookup : (map && map.maxLen ? map.maxLen : {});
                    const fieldMaxLen = maxLenMap[name] || maxLenMap[normalize(name)] || maxLenMap[String(name).toUpperCase()] || null;

                    // Force numeric-only 6-char behavior for known fuel/amount fields (defensive)
                    const forceNumericFields = [
                        'res_lit','res_kg','block_fuel','total_actual','lt','la','ca','ra'
                    ];
                    const mappedKey = mapped || '';
                    const forcePad = forceNumericFields.includes(String(mappedKey)) || (String(normalize(name)).includes('ikmal')) || (String(normalize(name)).includes('supply')) || (String(normalize(name)).includes('block'));

                    // If this field requires 6-char numeric formatting: draw each character into separate box
                    // But never apply pad6 rendering to the temperature field (we handle it as sign+chars)
                    if((needsPad6 || forcePad) && !(typeof isTempField !== 'undefined' && isTempField)){
                        try{
                            // prepare chars: only digits, right-aligned into fieldLen slots; empty slots become space
                            let raw = String(value || '');
                            // remove dots/commas/other punctuation to satisfy "no separators" requirement
                            raw = raw.replace(/[.,]/g,'');
                            let digits = raw.replace(/\D/g,'');
                            const fieldLen = (fieldMaxLen && Number(fieldMaxLen) > 0) ? Number(fieldMaxLen) : 6;
                            if(digits.length > fieldLen) digits = digits.slice(-fieldLen);
                            // pad with plain spaces to required width
                            digits = digits.padStart(fieldLen, ' ');
                            // If there are no digits at all, show a single '0' in the rightmost box
                            if(digits.trim() === '') digits = '0'.padStart(fieldLen, ' ');

                            // attempt to get widget rectangle using pdf-lib internals
                            const acroField = f.acroField;
                            let rect = null;
                            try{
                                const widgets = acroField.getWidgets ? acroField.getWidgets() : (acroField.dict.get ? acroField.dict.get(PDFLib.PDFName.of('Kids')) : null);
                                if(widgets && widgets.length){
                                    const w = widgets[0];
                                    if(typeof w.getRectangle === 'function') rect = w.getRectangle();
                                    else if(w.get('Rect')) rect = w.get('Rect');
                                }
                            }catch(e){}

                            if(rect){
                                // rect may be array [x1,y1,x2,y2]
                                const llx = rect[0];
                                const lly = rect[1];
                                const urx = rect[2];
                                const ury = rect[3];
                                const width = urx - llx;
                                const height = ury - lly;
                                const charW = width / fieldLen;

                                const pages = pdfDoc.getPages();
                                const page = pages[0];
                                // Try to read DA for font/size/color, fallback to Helvetica
                                let drawFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                                let drawColor = PDFLib.rgb(0,0.38,0.89);
                                let drawFontSize = Math.min(height * 0.9, 18);
                                try{
                                    let da = null;
                                    try{ da = (acroField.getDefaultAppearance && typeof acroField.getDefaultAppearance === 'function') ? acroField.getDefaultAppearance() : null; }catch(e){}
                                    if(!da && acroField.dict && acroField.dict.get){
                                        try{ const daObj = acroField.dict.get(PDFLib.PDFName.of('DA')); da = daObj ? String(daObj) : null; }catch(e){}
                                    }
                                    if(da){
                                        const parts = String(da).trim().split(/\s+/);
                                        for(let i=0;i<parts.length;i++){
                                            const t = parts[i];
                                            if(t === 'Tf' && i>=2){
                                                drawFontSize = parseFloat(parts[i-1]) || drawFontSize;
                                                const fn = parts[i-2] || null;
                                                if(fn && fn.indexOf('/') === 0){
                                                    const fnn = fn.replace('/','');
                                                    const map = { 'Helv':'Helvetica', 'Helvetica':'Helvetica', 'TiRo':'TimesRoman', 'Times':'TimesRoman', 'Cour':'Courier', 'Courier':'Courier' };
                                                    let std = null;
                                                    for(const k of Object.keys(map)) if(fnn.indexOf(k) !== -1){ std = map[k]; break; }
                                                    if(std === 'Helvetica') drawFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                                                    else if(std === 'TimesRoman') drawFont = await pdfDoc.embedFont(PDFLib.StandardFonts.TimesRoman);
                                                    else if(std === 'Courier') drawFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Courier);
                                                }
                                            }
                                            if(t === 'rg' && i>=3){
                                                const r = parseFloat(parts[i-3]) || 0;
                                                const g = parseFloat(parts[i-2]) || 0;
                                                const b = parseFloat(parts[i-1]) || 0;
                                                drawColor = PDFLib.rgb(r,g,b);
                                            }
                                        }
                                    }
                                }catch(e){}
                                for(let i=0;i<fieldLen;i++){
                                    const ch = digits[i];
                                    const cx = llx + (i + 0.5) * charW;
                                    const drawX = cx - (drawFontSize * 0.25);
                                    const drawY = lly + (height - drawFontSize) / 2;
                                    if(ch && ch !== ' '){
                                        page.drawText(ch, { x: drawX, y: drawY, size: drawFontSize, font: drawFont, color: drawColor });
                                    }
                                }
                                continue;
                            }

                            // fallback: try to draw into widget rect; if not possible, set the field value
                            try{
                                const drawn = await drawTextIntoWidget(f, digits);
                                console.debug('[pdf-fill-debug] drawTextIntoWidget', name, 'drawn=', drawn);
                                if(drawn){ makeFieldBackgroundTransparent(f); continue; }
                            }catch(e){ console.error('[pdf-fill-error] drawTextIntoWidget', name, e); }
                            try{
                                const tf = form.getTextField(name);
                                if(tf){
                                    try{ tf.setText(digits); makeFieldBackgroundTransparent(f); console.debug('[pdf-fill-debug] form.getTextField.setText OK', name, digits); continue; }
                                    catch(e){
                                        console.error('[pdf-fill-error] form.getTextField.setText', name, e);
                                        // If error indicates maxLength, try to shorten value and retry
                                        try{
                                            const m = String(e && e.message || '').match(/maxLength=(\d+)/i);
                                            if(m && m[1]){
                                                const allowed = Number(m[1]);
                                                const trimmed = String(digits).slice(-allowed);
                                                tf.setText(trimmed); makeFieldBackgroundTransparent(f); console.debug('[pdf-fill-debug] form.getTextField.setText RETRY trimmed', name, trimmed); continue;
                                            }
                                        }catch(e2){ console.error('[pdf-fill-error] retry setText', name, e2); }
                                    }
                                }
                            }catch(e){ console.error('[pdf-fill-error] form.getTextField.setText', name, e); }
                            try{
                                if(typeof f.setText === 'function') {
                                    try{ f.setText(digits); makeFieldBackgroundTransparent(f); console.debug('[pdf-fill-debug] field.setText OK', name, digits); continue; }
                                    catch(e){
                                        console.error('[pdf-fill-error] field.setText', name, e);
                                        try{
                                            const m = String(e && e.message || '').match(/maxLength=(\d+)/i);
                                            if(m && m[1]){
                                                const allowed = Number(m[1]);
                                                const trimmed = String(digits).slice(-allowed);
                                                f.setText(trimmed); makeFieldBackgroundTransparent(f); console.debug('[pdf-fill-debug] field.setText RETRY trimmed', name, trimmed); continue;
                                            }
                                        }catch(e2){ console.error('[pdf-fill-error] retry field.setText', name, e2); }
                                    }
                                }
                            }catch(e){ console.error('[pdf-fill-error] field.setText', name, e); }
                        }catch(e){ /* fallback to simple setText below */ }
                    }

                    // Apply maxLen padding/trimming for non-pad6 fields (or fallback after pad6 failure)
                    let finalVal = setVal;
                    try{
                        if(fieldMaxLen !== null){
                            let raw = String(setVal || '');
                            // Special case: KUYRUK KODU should be exactly the tail characters, no padding
                            if((name && String(name).toUpperCase() === 'KUYRUK KODU') || normalize(name) === normalize('KUYRUK KODU')){
                                let cleaned = raw.toString().trim().toUpperCase().replace(/[^A-Z0-9]/g,'');
                                if(cleaned.length > fieldMaxLen) cleaned = cleaned.slice(-fieldMaxLen);
                                finalVal = cleaned;
                            }
                            // Special-case: temperature field (SICAKLIK C) -> keep leading sign and pad on the right
                            else if((typeof isTempField !== 'undefined' && isTempField) || (name && String(name).toUpperCase() === 'SICAKLIK C') || normalize(name) === normalize('SICAKLIK C')){
                                let out = raw;
                                if(out.length > fieldMaxLen) out = out.slice(0, fieldMaxLen);
                                else out = out.padEnd(fieldMaxLen, ' ');
                                finalVal = out;
                            } else {
                                // remove punctuation for numeric/text and then decide
                                const cleanedRaw = raw.replace(/[.,]/g,'').trim();
                                const isNumericLike = /^[0-9\s]+$/.test(cleanedRaw);
                                if(isNumericLike){
                                    let cleaned = cleanedRaw;
                                    if(cleaned.length > fieldMaxLen) cleaned = cleaned.slice(-fieldMaxLen);
                                    finalVal = cleaned.padStart(fieldMaxLen, ' ');
                                } else {
                                    let cleaned = cleanedRaw;
                                    if(cleaned.length > fieldMaxLen) cleaned = cleaned.slice(0, fieldMaxLen);
                                    finalVal = cleaned.padStart(fieldMaxLen, ' ');
                                }
                            }
                        }
                    }catch(e){ finalVal = setVal; }

                    try{
                        const drawn = await drawTextIntoWidget(f, finalVal);
                        console.debug('[pdf-fill-debug] drawTextIntoWidget(final)', name, 'drawn=', drawn);
                        if(drawn){ makeFieldBackgroundTransparent(f); continue; }
                    }catch(e){ console.error('[pdf-fill-error] drawTextIntoWidget(final)', name, e); }
                    try{
                        const tf2 = form.getTextField(name);
                        if(tf2){
                            try{ tf2.setText(finalVal); makeFieldBackgroundTransparent(f); console.debug('[pdf-fill-debug] form.getTextField.setText(final) OK', name, finalVal); continue; }
                            catch(e){
                                console.error('[pdf-fill-error] form.getTextField.setText(final)', name, e);
                                try{
                                    const m = String(e && e.message || '').match(/maxLength=(\d+)/i);
                                    if(m && m[1]){
                                        const allowed = Number(m[1]);
                                        const trimmed = String(finalVal).slice(-allowed);
                                        tf2.setText(trimmed); makeFieldBackgroundTransparent(f); console.debug('[pdf-fill-debug] form.getTextField.setText(final) RETRY trimmed', name, trimmed); continue;
                                    }
                                }catch(e2){ console.error('[pdf-fill-error] retry form.setText(final)', name, e2); }
                            }
                        }
                    }catch(e){ console.error('[pdf-fill-error] form.getTextField.setText(final)', name, e); }
                    try{
                        if(typeof f.setText === 'function') {
                            try{ f.setText(finalVal); makeFieldBackgroundTransparent(f); console.debug('[pdf-fill-debug] field.setText(final) OK', name, finalVal); }
                            catch(e){
                                console.error('[pdf-fill-error] field.setText(final)', name, e);
                                try{
                                    const m = String(e && e.message || '').match(/maxLength=(\d+)/i);
                                    if(m && m[1]){
                                        const allowed = Number(m[1]);
                                        const trimmed = String(finalVal).slice(-allowed);
                                        f.setText(trimmed); makeFieldBackgroundTransparent(f); console.debug('[pdf-fill-debug] field.setText(final) RETRY trimmed', name, trimmed);
                                    }
                                }catch(e2){ console.error('[pdf-fill-error] retry field.setText(final)', name, e2); }
                            }
                        }
                    }catch(e){ console.error('[pdf-fill-error] field.setText(final)', name, e); }
                }catch(e){ /* ignore per-field errors */ }
            }

                    try{
                        // Ensure field appearances are updated so values are visible in PDF viewers
                        try{ if(typeof form.updateFieldAppearances === 'function') form.updateFieldAppearances(embeddedFont || helv); }catch(e){}
                    
                    // --- end of PDF generation logic ---
                        // Fallback: set NeedAppearances flag on AcroForm for viewers that respect it
                        try{
                            const root = pdfDoc.context.lookup(pdfDoc.context.trailer.get(PDFLib.PDFName.of('Root')));
                            const ac = root && root.get ? root.get(PDFLib.PDFName.of('AcroForm')) : null;
                            if(ac && ac.set){
                                try{ ac.set(PDFLib.PDFName.of('NeedAppearances'), pdfDoc.context.obj(true)); }catch(e){}
                            }
                        }catch(e){}
                        try{ form.flatten(); }catch(e){}
                    }catch(e){}

            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], {type: 'application/pdf'});
            // Show PDF in modal iframe instead of forcing download
            try { if (_lastReceiptBlobUrl) { try { URL.revokeObjectURL(_lastReceiptBlobUrl); } catch(e){} } } catch(e){}
            const url = URL.createObjectURL(blob);
            _lastReceiptBlobUrl = url;
            // Open generated PDF in a new tab. If popup blocked, fall back to creating a temporary anchor.
            try {
<<<<<<< HEAD
                const newWin = window.open(_lastReceiptBlobUrl, '_blank', 'noopener,noreferrer');
                if (!newWin) {
                    const a = document.createElement('a');
                    a.href = _lastReceiptBlobUrl;
                    a.target = '_blank';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                }
            } catch (e) {
                const a = document.createElement('a');
                a.href = _lastReceiptBlobUrl;
                a.target = '_blank';
                document.body.appendChild(a);
                a.click();
                a.remove();
=======
                showPdfInOverlay(_lastReceiptBlobUrl, 'yakit-fisi.pdf');
            } catch (e) {
                try {
                    const a = document.createElement('a');
                    a.href = _lastReceiptBlobUrl;
                    a.download = 'yakit-fisi.pdf';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                } catch (e2) {}
>>>>>>> 007becc (chore: prepare release v7.3.48)
            }
            // Ensure modal/iframe remain hidden when opening in new tab
            try { const iframe = document.getElementById('receipt-iframe'); if (iframe) { iframe.style.display = 'none'; iframe.src = ''; } } catch(e){}
            try { const details = document.getElementById('r-details'); if (details) details.style.display = 'none'; } catch(e){}
            try { const receiptModalEl = document.getElementById('receipt-modal'); if (receiptModalEl) { receiptModalEl.style.display = 'none'; receiptModalEl.style.pointerEvents = 'none'; } } catch(e){}
            btn.textContent = 'Fiş Görüntülendi';
        }catch(err){
            console.error('PDF oluşturulurken hata:', err);
            btn.textContent = 'Fiş Yazdır';
        }finally{ btn.disabled = false; }
    });
})();
</script>
    <script>
    // Service Worker register helper — otomatik kayıt + console'dan hızlı unregister
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js')
            .then(reg => console.log('SW registered:', reg.scope))
            .catch(err => console.error('SW registration failed:', err));
    }

    window.__unregisterSW = async function() {
        if (!('serviceWorker' in navigator)) return console.log('ServiceWorker desteklenmiyor');
        const regs = await navigator.serviceWorker.getRegistrations();
        await Promise.all(regs.map(r => r.unregister()));
        console.log('Service worker kayıtları kaldırıldı:', regs.map(r => r.scope));
    };
    </script>
</body>
</html>
